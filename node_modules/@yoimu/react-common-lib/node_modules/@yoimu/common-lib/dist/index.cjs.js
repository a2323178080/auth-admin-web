'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const createEnum = obj => {
	const translation = {};
	const reverseEnum = {};
	const $enum = {};
	const keys = [];
	const t = val => translation[val];
	const key = val => reverseEnum[val];
	const map = callback =>
		callback ? keys.map((k, i) => callback($enum[k], k, i)) : keys;
	const reduce = (callback, initialValue) => {
		let previous = initialValue;
		keys.map((k, i) => {
			previous = callback(previous, $enum[k], k, i);
		});
		return previous
	};

	function addEnum(key, val) {
		if (Array.isArray(val)) {
			const [v, t] = val;
			translation[v] = t;
			$enum[key] = v;
			reverseEnum[v] = key;
		} else {
			$enum[key] = val;
			reverseEnum[val] = key;
		}
		keys.push(key);
	}

	for (const k in obj) {
		addEnum(k, obj[k]);
	}

	return { ...$enum, t, key, keys, map, reduce }
};

/*
  使用範例
  申明：
  值(v) or [值(v), 翻譯(t), 描述(d)]
  declareEnum({ START: [0], END: [1] })
  declareEnum({ START: [0, '開始'], END: [1, '結束'] })
  declareEnum({ START: [0, '開始', 'START'], END: [1, '結束', 'END'] })
 */
const declareEnum = (obj, typeBindValue) => {
	const keys = [];
	let length = 0;
	const map = callback => {
		if (!callback) return []

		const list = [];
		for (let i = 0; i < keys.length; i++) {
			const k = keys[i];
			list.push(callback(result[k], k, i));
		}
		return list
	};
	const result = { keys, length, map };

	if (typeof obj === 'object') {
		for (const k in obj) {
			const e = obj[k];

			keys.push(k);
			length += 1;

			if (Array.isArray(e)) {
				const v = e[0];
				result[k] = v;

				for (let i = 1; i < e.length; i++)
					switch (i) {
						case 1:
							if (result.t == null) result.t = {};
							result.t[v] = e[i];
							break
						case 2:
							if (result.d == null) result.d = {};
							result.d[v] = e[i];
							break
					}
			} else {
				result[k] = e;
			}
		}
	}

	return result
};

const stepPrice = (() => {
	const stepRegs = {};
	const createStepReg = step => {
		const sp = Array.from(new Array(step), (_, i) => i).reduce(
			p => p + '\\d',
			'',
		);
		stepRegs[step] = new RegExp(`(\\d)(?=(${sp})+(?!\\d))`, 'g');
		return stepRegs[step]
	};
	return (price, step = 3) => {
		let _price = price;

		if (typeof price === 'number') _price = String(price);

		if (typeof _price === 'string') {
			const priceReg = stepRegs[step] || createStepReg(step);
			let sptPrices = [];
			if (_price.includes('.')) {
				sptPrices = _price.split('.');
			}
			if (sptPrices.length) {
				_price = sptPrices[0].replace(priceReg, '$1,') + '.' + sptPrices[1];
			} else {
				_price = _price.replace(priceReg, '$1,');
			}
		}
		return _price
	}
})();

// [simple][traditional]...
const stObj = {
	s万: '萬',
	t萬: '万',
	s与: '與',
	t與: '与',
	s丑: '醜',
	t醜: '丑',
	s专: '專',
	t專: '专',
	s业: '業',
	t業: '业',
	s丛: '叢',
	t叢: '丛',
	s东: '東',
	t東: '东',
	s丝: '絲',
	t絲: '丝',
	s丢: '丟',
	t丟: '丢',
	s两: '兩',
	t兩: '两',
	s严: '嚴',
	t嚴: '严',
	s丧: '喪',
	t喪: '丧',
	s个: '個',
	t個: '个',
	s丬: '爿',
	t爿: '丬',
	s丰: '豐',
	t豐: '丰',
	s临: '臨',
	t臨: '临',
	s为: '為',
	t為: '为',
	s丽: '麗',
	t麗: '丽',
	s举: '舉',
	t舉: '举',
	s么: '麼',
	t麼: '么',
	s义: '義',
	t義: '义',
	s乌: '烏',
	t烏: '乌',
	s乐: '樂',
	t樂: '乐',
	s乔: '喬',
	t喬: '乔',
	s习: '習',
	t習: '习',
	s乡: '鄉',
	t鄉: '乡',
	s书: '書',
	t書: '书',
	s买: '買',
	t買: '买',
	s乱: '亂',
	t亂: '乱',
	s争: '爭',
	t爭: '争',
	s于: '於',
	t於: '于',
	s亏: '虧',
	t虧: '亏',
	s云: '雲',
	t雲: '云',
	s亘: '亙',
	t亙: '亘',
	s亚: '亞',
	t亞: '亚',
	s产: '產',
	t產: '产',
	s亩: '畝',
	t畝: '亩',
	s亲: '親',
	t親: '亲',
	s亵: '褻',
	t褻: '亵',
	s亸: '嚲',
	t嚲: '亸',
	s亿: '億',
	t億: '亿',
	s仅: '僅',
	t僅: '仅',
	s从: '從',
	t從: '从',
	s仑: '侖',
	t侖: '仑',
	s仓: '倉',
	t倉: '仓',
	s仪: '儀',
	t儀: '仪',
	s们: '們',
	t們: '们',
	s价: '價',
	t價: '价',
	s众: '眾',
	t眾: '众',
	s优: '優',
	t優: '优',
	s伙: '夥',
	t夥: '伙',
	s会: '會',
	t會: '会',
	s伛: '傴',
	t傴: '伛',
	s伞: '傘',
	t傘: '伞',
	s伟: '偉',
	t偉: '伟',
	s传: '傳',
	t傳: '传',
	s伤: '傷',
	t傷: '伤',
	s伥: '倀',
	t倀: '伥',
	s伦: '倫',
	t倫: '伦',
	s伧: '傖',
	t傖: '伧',
	s伪: '偽',
	t偽: '伪',
	s伫: '佇',
	t佇: '伫',
	s体: '體',
	t體: '体',
	s余: '餘',
	t餘: '馀',
	s佣: '傭',
	t傭: '佣',
	s佥: '僉',
	t僉: '佥',
	s侠: '俠',
	t俠: '侠',
	s侣: '侶',
	t侶: '侣',
	s侥: '僥',
	t僥: '侥',
	s侦: '偵',
	t偵: '侦',
	s侧: '側',
	t側: '侧',
	s侨: '僑',
	t僑: '侨',
	s侩: '儈',
	t儈: '侩',
	s侪: '儕',
	t儕: '侪',
	s侬: '儂',
	t儂: '侬',
	s俣: '俁',
	t俁: '俣',
	s俦: '儔',
	t儔: '俦',
	s俨: '儼',
	t儼: '俨',
	s俩: '倆',
	t倆: '俩',
	s俪: '儷',
	t儷: '俪',
	s俭: '儉',
	t儉: '俭',
	s债: '債',
	t債: '债',
	s倾: '傾',
	t傾: '倾',
	s偬: '傯',
	t傯: '偬',
	s偻: '僂',
	t僂: '偻',
	s偾: '僨',
	t僨: '偾',
	s偿: '償',
	t償: '偿',
	s傥: '儻',
	t儻: '傥',
	s傧: '儐',
	t儐: '傧',
	s储: '儲',
	t儲: '储',
	s傩: '儺',
	t儺: '傩',
	s儿: '兒',
	t兒: '儿',
	s兑: '兌',
	t兌: '兑',
	s兖: '兗',
	t兗: '兖',
	s党: '黨',
	t黨: '党',
	s兰: '蘭',
	t蘭: '兰',
	s关: '關',
	t關: '关',
	s兴: '興',
	t興: '兴',
	s兹: '茲',
	t茲: '兹',
	s养: '養',
	t養: '养',
	s兽: '獸',
	t獸: '兽',
	s冁: '囅',
	t囅: '冁',
	s内: '內',
	t內: '内',
	s冈: '岡',
	t岡: '冈',
	s册: '冊',
	t冊: '册',
	s写: '寫',
	t寫: '写',
	s军: '軍',
	t軍: '军',
	s农: '農',
	t農: '农',
	s冢: '塚',
	t塚: '冢',
	s冯: '馮',
	t馮: '冯',
	s冲: '衝',
	t衝: '冲',
	s决: '決',
	t決: '决',
	s况: '況',
	t況: '况',
	s冻: '凍',
	t凍: '冻',
	s净: '淨',
	t淨: '净',
	s凄: '淒',
	t淒: '凄',
	s凉: '涼',
	t涼: '凉',
	s凌: '淩',
	t淩: '凌',
	s减: '減',
	t減: '减',
	s凑: '湊',
	t湊: '凑',
	s凛: '凜',
	t凜: '凛',
	s几: '幾',
	t幾: '几',
	s凤: '鳳',
	t鳳: '凤',
	s凫: '鳧',
	t鳧: '凫',
	s凭: '憑',
	t憑: '凭',
	s凯: '凱',
	t凱: '凯',
	s击: '擊',
	t擊: '击',
	s凼: '氹',
	t氹: '凼',
	s凿: '鑿',
	t鑿: '凿',
	s刍: '芻',
	t芻: '刍',
	s划: '劃',
	t劃: '划',
	s刘: '劉',
	t劉: '刘',
	s则: '則',
	t則: '则',
	s刚: '剛',
	t剛: '刚',
	s创: '創',
	t創: '创',
	s删: '刪',
	t刪: '删',
	s别: '彆',
	t別: '别',
	s刬: '剗',
	t剗: '刬',
	s刭: '剄',
	t剄: '刭',
	s刽: '劊',
	t劊: '刽',
	s刿: '劌',
	t劌: '刿',
	s剀: '剴',
	t剴: '剀',
	s剂: '劑',
	t劑: '剂',
	s剐: '剮',
	t剮: '剐',
	s剑: '劍',
	t劍: '剑',
	s剥: '剝',
	t剝: '剥',
	s剧: '劇',
	t劇: '剧',
	s劝: '勸',
	t勸: '劝',
	s办: '辦',
	t辦: '办',
	s务: '務',
	t務: '务',
	s劢: '勱',
	t勱: '劢',
	s动: '動',
	t動: '动',
	s励: '勵',
	t勵: '励',
	s劲: '勁',
	t勁: '劲',
	s劳: '勞',
	t勞: '劳',
	s势: '勢',
	t勢: '势',
	s勋: '勳',
	t勳: '勋',
	s勐: '猛',
	t猛: '勐',
	s勚: '勩',
	t勩: '勚',
	s匀: '勻',
	t勻: '匀',
	s匦: '匭',
	t匭: '匦',
	s匮: '匱',
	t匱: '匮',
	s区: '區',
	t區: '区',
	s医: '醫',
	t醫: '医',
	s华: '華',
	t華: '华',
	s协: '協',
	t協: '协',
	s单: '單',
	t單: '单',
	s卖: '賣',
	t賣: '卖',
	s卢: '盧',
	t盧: '卢',
	s卤: '鹵',
	t鹵: '卤',
	s卧: '臥',
	t臥: '卧',
	s卫: '衛',
	t衛: '卫',
	s却: '卻',
	t卻: '却',
	s卺: '巹',
	t巹: '卺',
	s厂: '廠',
	t廠: '厂',
	s厅: '廳',
	t廳: '厅',
	s历: '曆',
	t曆: '历',
	s厉: '厲',
	t厲: '厉',
	s压: '壓',
	t壓: '压',
	s厌: '厭',
	t厭: '厌',
	s厍: '厙',
	t厙: '厍',
	s厕: '廁',
	t廁: '厕',
	s厢: '廂',
	t廂: '厢',
	s厣: '厴',
	t厴: '厣',
	s厦: '廈',
	t廈: '厦',
	s厨: '廚',
	t廚: '厨',
	s厩: '廄',
	t廄: '厩',
	s厮: '廝',
	t廝: '厮',
	s县: '縣',
	t縣: '县',
	s参: '參',
	t參: '参',
	s叆: '靉',
	t靉: '叆',
	s叇: '靆',
	t靆: '叇',
	s双: '雙',
	t雙: '双',
	s发: '發',
	t發: '发',
	s变: '變',
	t變: '变',
	s叙: '敘',
	t敘: '叙',
	s叠: '疊',
	t疊: '叠',
	s叶: '葉',
	t葉: '叶',
	s号: '號',
	t號: '号',
	s叹: '歎',
	t歎: '叹',
	s叽: '嘰',
	t嘰: '叽',
	s吁: '籲',
	t籲: '吁',
	s后: '後',
	t後: '后',
	s吓: '嚇',
	t嚇: '吓',
	s吕: '呂',
	t呂: '吕',
	s吗: '嗎',
	t嗎: '吗',
	s吣: '唚',
	t唚: '吣',
	s吨: '噸',
	t噸: '吨',
	s听: '聽',
	t聽: '听',
	s启: '啟',
	t啟: '启',
	s吴: '吳',
	t吳: '吴',
	s呒: '嘸',
	t嘸: '呒',
	s呓: '囈',
	t囈: '呓',
	s呕: '嘔',
	t嘔: '呕',
	s呖: '嚦',
	t嚦: '呖',
	s呗: '唄',
	t唄: '呗',
	s员: '員',
	t員: '员',
	s呙: '咼',
	t咼: '呙',
	s呛: '嗆',
	t嗆: '呛',
	s呜: '嗚',
	t嗚: '呜',
	s咏: '詠',
	t詠: '咏',
	s咔: '哢',
	t哢: '咔',
	s咙: '嚨',
	t嚨: '咙',
	s咛: '嚀',
	t嚀: '咛',
	s咝: '噝',
	t噝: '咝',
	s咤: '吒',
	t吒: '咤',
	s咴: '噅',
	t噅: '咴',
	s咸: '鹹',
	t鹹: '咸',
	s哌: '呱',
	t呱: '哌',
	s响: '響',
	t響: '响',
	s哑: '啞',
	t啞: '哑',
	s哒: '噠',
	t噠: '哒',
	s哓: '嘵',
	t嘵: '哓',
	s哔: '嗶',
	t嗶: '哔',
	s哕: '噦',
	t噦: '哕',
	s哗: '嘩',
	t嘩: '哗',
	s哙: '噲',
	t噲: '哙',
	s哜: '嚌',
	t嚌: '哜',
	s哝: '噥',
	t噥: '哝',
	s哟: '喲',
	t喲: '哟',
	s唛: '嘜',
	t嘜: '唛',
	s唝: '嗊',
	t嗊: '唝',
	s唠: '嘮',
	t嘮: '唠',
	s唡: '啢',
	t啢: '唡',
	s唢: '嗩',
	t嗩: '唢',
	s唣: '唕',
	t唕: '唣',
	s唤: '喚',
	t喚: '唤',
	s唿: '呼',
	t呼: '唿',
	s啧: '嘖',
	t嘖: '啧',
	s啬: '嗇',
	t嗇: '啬',
	s啭: '囀',
	t囀: '啭',
	s啮: '齧',
	t齧: '啮',
	s啰: '囉',
	t囉: '啰',
	s啴: '嘽',
	t嘽: '啴',
	s啸: '嘯',
	t嘯: '啸',
	s喷: '噴',
	t噴: '喷',
	s喽: '嘍',
	t嘍: '喽',
	s喾: '嚳',
	t嚳: '喾',
	s嗫: '囁',
	t囁: '嗫',
	s呵: '嗬',
	t嗬: '呵',
	s嗳: '噯',
	t噯: '嗳',
	s嘘: '噓',
	t噓: '嘘',
	s嘤: '嚶',
	t嚶: '嘤',
	s嘱: '囑',
	t囑: '嘱',
	s噜: '嚕',
	t嚕: '噜',
	s噼: '劈',
	t劈: '噼',
	s嚣: '囂',
	t囂: '嚣',
	s嚯: '謔',
	t謔: '谑',
	s团: '團',
	t團: '团',
	s园: '園',
	t園: '园',
	s囱: '囪',
	t囪: '囱',
	s围: '圍',
	t圍: '围',
	s囵: '圇',
	t圇: '囵',
	s国: '國',
	t國: '国',
	s图: '圖',
	t圖: '图',
	s圆: '圓',
	t圓: '圆',
	s圣: '聖',
	t聖: '圣',
	s圹: '壙',
	t壙: '圹',
	s场: '場',
	t場: '场',
	s坂: '阪',
	t阪: '坂',
	s坏: '壞',
	t壞: '坏',
	s块: '塊',
	t塊: '块',
	s坚: '堅',
	t堅: '坚',
	s坛: '壇',
	t壇: '坛',
	s坜: '壢',
	t壢: '坜',
	s坝: '壩',
	t壩: '坝',
	s坞: '塢',
	t塢: '坞',
	s坟: '墳',
	t墳: '坟',
	s坠: '墜',
	t墜: '坠',
	s垄: '壟',
	t壟: '垅',
	s垅: '壟',
	s垆: '壚',
	t壚: '垆',
	s垒: '壘',
	t壘: '垒',
	s垦: '墾',
	t墾: '垦',
	s垧: '坰',
	t坰: '垧',
	s垩: '堊',
	t堊: '垩',
	s垫: '墊',
	t墊: '埝',
	s垭: '埡',
	t埡: '垭',
	s垯: '墶',
	t墶: '垯',
	s垱: '壋',
	t壋: '垱',
	s垲: '塏',
	t塏: '垲',
	s垴: '堖',
	t堖: '垴',
	s埘: '塒',
	t塒: '埘',
	s埙: '塤',
	t塤: '埙',
	s埚: '堝',
	t堝: '埚',
	s埝: '墊',
	s埯: '垵',
	t垵: '埯',
	s堑: '塹',
	t塹: '堑',
	s堕: '墮',
	t墮: '堕',
	s塆: '壪',
	t壪: '塆',
	s墙: '牆',
	t牆: '墙',
	s壮: '壯',
	t壯: '壮',
	s声: '聲',
	t聲: '声',
	s壳: '殼',
	t殼: '壳',
	s壶: '壺',
	t壺: '壶',
	s壸: '壼',
	t壼: '壸',
	s处: '處',
	t處: '处',
	s备: '備',
	t備: '备',
	s复: '複',
	t複: '复',
	s够: '夠',
	t夠: '够',
	s头: '頭',
	t頭: '头',
	s夸: '誇',
	t誇: '夸',
	s夹: '夾',
	t夾: '夹',
	s夺: '奪',
	t奪: '夺',
	s奁: '奩',
	t奩: '奁',
	s奂: '奐',
	t奐: '奂',
	s奋: '奮',
	t奮: '奋',
	s奖: '獎',
	t獎: '奖',
	s奥: '奧',
	t奧: '奥',
	s妆: '妝',
	t妝: '妆',
	s妇: '婦',
	t婦: '妇',
	s妈: '媽',
	t媽: '妈',
	s妩: '嫵',
	t嫵: '妩',
	s妪: '嫗',
	t嫗: '妪',
	s妫: '媯',
	t媯: '妫',
	s姗: '姍',
	t姍: '姗',
	s姜: '薑',
	t薑: '姜',
	s娄: '婁',
	t婁: '娄',
	s娅: '婭',
	t婭: '娅',
	s娆: '嬈',
	t嬈: '娆',
	s娇: '嬌',
	t嬌: '娇',
	s娈: '孌',
	t孌: '娈',
	s娱: '娛',
	t娛: '娱',
	s娲: '媧',
	t媧: '娲',
	s娴: '嫻',
	t嫻: '娴',
	s婳: '嫿',
	t嫿: '婳',
	s婴: '嬰',
	t嬰: '婴',
	s婵: '嬋',
	t嬋: '婵',
	s婶: '嬸',
	t嬸: '婶',
	s媪: '媼',
	t媼: '媪',
	s嫒: '嬡',
	t嬡: '嫒',
	s嫔: '嬪',
	t嬪: '嫔',
	s嫱: '嬙',
	t嬙: '嫱',
	s嬷: '嬤',
	t嬤: '嬷',
	s孙: '孫',
	t孫: '孙',
	s学: '學',
	t學: '学',
	s孪: '孿',
	t孿: '孪',
	s宁: '寧',
	t寧: '宁',
	s宝: '寶',
	t寶: '宝',
	s实: '實',
	t實: '实',
	s宠: '寵',
	t寵: '宠',
	s审: '審',
	t審: '审',
	s宪: '憲',
	t憲: '宪',
	s宫: '宮',
	t宮: '宫',
	s宽: '寬',
	t寬: '宽',
	s宾: '賓',
	t賓: '宾',
	s寝: '寢',
	t寢: '寝',
	s对: '對',
	t對: '对',
	s寻: '尋',
	t尋: '寻',
	s导: '導',
	t導: '导',
	s寿: '壽',
	t壽: '寿',
	s将: '將',
	t將: '将',
	s尔: '爾',
	t爾: '尔',
	s尘: '塵',
	t塵: '尘',
	s尧: '堯',
	t堯: '尧',
	s尴: '尷',
	t尷: '尴',
	s尸: '屍',
	t屍: '尸',
	s尽: '儘',
	t盡: '尽',
	s层: '層',
	t層: '层',
	s屃: '屭',
	t屭: '屃',
	s屉: '屜',
	t屜: '屉',
	s届: '屆',
	t屆: '届',
	s属: '屬',
	t屬: '属',
	s屡: '屢',
	t屢: '屡',
	s屦: '屨',
	t屨: '屦',
	s屿: '嶼',
	t嶼: '屿',
	s岁: '歲',
	t歲: '岁',
	s岂: '豈',
	t豈: '岂',
	s岖: '嶇',
	t嶇: '岖',
	s岗: '崗',
	t崗: '岗',
	s岘: '峴',
	t峴: '岘',
	s岙: '嶴',
	t嶴: '岙',
	s岚: '嵐',
	t嵐: '岚',
	s岛: '島',
	t島: '岛',
	s岭: '嶺',
	t嶺: '岭',
	s岳: '嶽',
	t嶽: '岳',
	s岽: '崠',
	t崠: '岽',
	s岿: '巋',
	t巋: '岿',
	s峃: '嶨',
	t嶨: '峃',
	s峄: '嶧',
	t嶧: '峄',
	s峡: '峽',
	t峽: '峡',
	s峣: '嶢',
	t嶢: '峣',
	s峤: '嶠',
	t嶠: '峤',
	s峥: '崢',
	t崢: '峥',
	s峦: '巒',
	t巒: '峦',
	s崂: '嶗',
	t嶗: '崂',
	s崃: '崍',
	t崍: '崃',
	s崄: '嶮',
	t嶮: '崄',
	s崭: '嶄',
	t嶄: '崭',
	s嵘: '嶸',
	t嶸: '嵘',
	s嵚: '嶔',
	t嶔: '嵚',
	s嵛: '崳',
	t崳: '嵛',
	s嵝: '嶁',
	t嶁: '嵝',
	s嵴: '脊',
	t脊: '嵴',
	s巅: '巔',
	t巔: '巅',
	s巩: '鞏',
	t鞏: '巩',
	s巯: '巰',
	t巰: '巯',
	s币: '幣',
	t幣: '币',
	s帅: '帥',
	t帥: '帅',
	s师: '師',
	t師: '师',
	s帏: '幃',
	t幃: '帏',
	s帐: '帳',
	t帳: '帐',
	s帘: '簾',
	t簾: '帘',
	s帜: '幟',
	t幟: '帜',
	s带: '帶',
	t帶: '带',
	s帧: '幀',
	t幀: '帧',
	s帮: '幫',
	t幫: '帮',
	s帱: '幬',
	t幬: '帱',
	s帻: '幘',
	t幘: '帻',
	s帼: '幗',
	t幗: '帼',
	s幂: '冪',
	t冪: '幂',
	s幞: '襆',
	t襆: '幞',
	s干: '乾',
	t幹: '干',
	s并: '並',
	t並: '并',
	s广: '廣',
	t廣: '广',
	s庄: '莊',
	t莊: '庄',
	s庆: '慶',
	t慶: '庆',
	s庐: '廬',
	t廬: '庐',
	s庑: '廡',
	t廡: '庑',
	s库: '庫',
	t庫: '库',
	s应: '應',
	t應: '应',
	s庙: '廟',
	t廟: '庙',
	s庞: '龐',
	t龐: '庞',
	s废: '廢',
	t廢: '废',
	s庼: '廎',
	t廎: '庼',
	s廪: '廩',
	t廩: '廪',
	s开: '開',
	t開: '开',
	s异: '異',
	t異: '异',
	s弃: '棄',
	t棄: '弃',
	s张: '張',
	t張: '张',
	s弥: '彌',
	t彌: '弥',
	s弪: '弳',
	t弳: '弪',
	s弯: '彎',
	t彎: '弯',
	s弹: '彈',
	t彈: '弹',
	s强: '強',
	t強: '犟',
	s归: '歸',
	t歸: '归',
	s当: '當',
	t當: '当',
	s录: '錄',
	t錄: '录',
	s彟: '彠',
	t彠: '彟',
	s彦: '彥',
	t彥: '彦',
	s彻: '徹',
	t徹: '彻',
	s径: '徑',
	t徑: '径',
	s徕: '徠',
	t徠: '徕',
	s御: '禦',
	t禦: '御',
	s忆: '憶',
	t憶: '忆',
	s忏: '懺',
	t懺: '忏',
	s忧: '憂',
	t憂: '忧',
	s忾: '愾',
	t愾: '忾',
	s怀: '懷',
	t懷: '怀',
	s态: '態',
	t態: '态',
	s怂: '慫',
	t慫: '怂',
	s怃: '憮',
	t憮: '怃',
	s怄: '慪',
	t慪: '怄',
	s怅: '悵',
	t悵: '怅',
	s怆: '愴',
	t愴: '怆',
	s怜: '憐',
	t憐: '怜',
	s总: '總',
	t總: '总',
	s怼: '懟',
	t懟: '怼',
	s怿: '懌',
	t懌: '怿',
	s恋: '戀',
	t戀: '恋',
	s恳: '懇',
	t懇: '恳',
	s恶: '惡',
	t惡: '恶',
	s恸: '慟',
	t慟: '恸',
	s恹: '懨',
	t懨: '恹',
	s恺: '愷',
	t愷: '恺',
	s恻: '惻',
	t惻: '恻',
	s恼: '惱',
	t惱: '恼',
	s恽: '惲',
	t惲: '恽',
	s悦: '悅',
	t悅: '悦',
	s悫: '愨',
	t愨: '悫',
	s悬: '懸',
	t懸: '悬',
	s悭: '慳',
	t慳: '悭',
	s悯: '憫',
	t憫: '悯',
	s惊: '驚',
	t驚: '惊',
	s惧: '懼',
	t懼: '惧',
	s惨: '慘',
	t慘: '惨',
	s惩: '懲',
	t懲: '惩',
	s惫: '憊',
	t憊: '惫',
	s惬: '愜',
	t愜: '惬',
	s惭: '慚',
	t慚: '惭',
	s惮: '憚',
	t憚: '惮',
	s惯: '慣',
	t慣: '惯',
	s愍: '湣',
	t湣: '愍',
	s愠: '慍',
	t慍: '愠',
	s愤: '憤',
	t憤: '愤',
	s愦: '憒',
	t憒: '愦',
	s愿: '願',
	t願: '愿',
	s慑: '懾',
	t懾: '慑',
	s慭: '憖',
	t憖: '慭',
	s憷: '怵',
	t怵: '憷',
	s懑: '懣',
	t懣: '懑',
	s懒: '懶',
	t懶: '懒',
	s懔: '懍',
	t懍: '懔',
	s戆: '戇',
	t戇: '戆',
	s戋: '戔',
	t戔: '戋',
	s戏: '戲',
	t戲: '戏',
	s戗: '戧',
	t戧: '戗',
	s战: '戰',
	t戰: '战',
	s戬: '戩',
	t戩: '戬',
	s户: '戶',
	t戶: '户',
	s扎: '紮',
	t紮: '扎',
	s扑: '撲',
	t撲: '扑',
	s扦: '扡',
	t扡: '扦',
	s执: '執',
	t執: '执',
	s扩: '擴',
	t擴: '扩',
	s扪: '捫',
	t捫: '扪',
	s扫: '掃',
	t掃: '扫',
	s扬: '揚',
	t揚: '扬',
	s扰: '擾',
	t擾: '扰',
	s抚: '撫',
	t撫: '抚',
	s抛: '拋',
	t拋: '抛',
	s抟: '摶',
	t摶: '抟',
	s抠: '摳',
	t摳: '抠',
	s抡: '掄',
	t掄: '抡',
	s抢: '搶',
	t搶: '抢',
	s护: '護',
	t護: '护',
	s报: '報',
	t報: '报',
	s担: '擔',
	t擔: '担',
	s拟: '擬',
	t擬: '拟',
	s拢: '攏',
	t攏: '拢',
	s拣: '揀',
	t揀: '拣',
	s拥: '擁',
	t擁: '拥',
	s拦: '攔',
	t攔: '拦',
	s拧: '擰',
	t擰: '拧',
	s拨: '撥',
	t撥: '拨',
	s择: '擇',
	t擇: '择',
	s挂: '掛',
	t掛: '挂',
	s挚: '摯',
	t摯: '挚',
	s挛: '攣',
	t攣: '挛',
	s挜: '掗',
	t掗: '挜',
	s挝: '撾',
	t撾: '挝',
	s挞: '撻',
	t撻: '挞',
	s挟: '挾',
	t挾: '挟',
	s挠: '撓',
	t撓: '挠',
	s挡: '擋',
	t擋: '挡',
	s挢: '撟',
	t撟: '挢',
	s挣: '掙',
	t掙: '挣',
	s挤: '擠',
	t擠: '挤',
	s挥: '揮',
	t揮: '挥',
	s挦: '撏',
	t撏: '挦',
	s捞: '撈',
	t撈: '捞',
	s损: '損',
	t損: '损',
	s捡: '撿',
	t撿: '捡',
	s换: '換',
	t換: '换',
	s捣: '搗',
	t搗: '捣',
	s据: '據',
	t據: '据',
	s捻: '撚',
	t撚: '捻',
	s掳: '擄',
	t擄: '掳',
	s掴: '摑',
	t摑: '掴',
	s掷: '擲',
	t擲: '掷',
	s掸: '撣',
	t撣: '掸',
	s掺: '摻',
	t摻: '掺',
	s掼: '摜',
	t摜: '掼',
	s揸: '摣',
	t摣: '揸',
	s揽: '攬',
	t攬: '揽',
	s揿: '撳',
	t撳: '揿',
	s搀: '攙',
	t攙: '搀',
	s搁: '擱',
	t擱: '搁',
	s搂: '摟',
	t摟: '搂',
	s搅: '攪',
	t攪: '搅',
	s携: '攜',
	t攜: '携',
	s摄: '攝',
	t攝: '摄',
	s摅: '攄',
	t攄: '摅',
	s摆: '擺',
	t擺: '摆',
	s摇: '搖',
	t搖: '摇',
	s摈: '擯',
	t擯: '摈',
	s摊: '攤',
	t攤: '摊',
	s撄: '攖',
	t攖: '撄',
	s撑: '撐',
	t撐: '撑',
	s撵: '攆',
	t攆: '撵',
	s撷: '擷',
	t擷: '撷',
	s撸: '擼',
	t擼: '撸',
	s撺: '攛',
	t攛: '撺',
	s擞: '擻',
	t擻: '擞',
	s攒: '攢',
	t攢: '攒',
	s敌: '敵',
	t敵: '敌',
	s敛: '斂',
	t斂: '敛',
	s数: '數',
	t數: '数',
	s斋: '齋',
	t齋: '斋',
	s斓: '斕',
	t斕: '斓',
	s斗: '鬥',
	t鬥: '斗',
	s斩: '斬',
	t斬: '斩',
	s断: '斷',
	t斷: '断',
	s无: '無',
	t無: '无',
	s旧: '舊',
	t舊: '旧',
	s时: '時',
	t時: '时',
	s旷: '曠',
	t曠: '旷',
	s旸: '暘',
	t暘: '旸',
	s昙: '曇',
	t曇: '昙',
	s昼: '晝',
	t晝: '昼',
	s昽: '曨',
	t曨: '昽',
	s显: '顯',
	t顯: '显',
	s晋: '晉',
	t晉: '晋',
	s晒: '曬',
	t曬: '晒',
	s晓: '曉',
	t曉: '晓',
	s晔: '曄',
	t曄: '晔',
	s晕: '暈',
	t暈: '晕',
	s晖: '暉',
	t暉: '晖',
	s暂: '暫',
	t暫: '暂',
	s暧: '曖',
	t曖: '暧',
	s札: '劄',
	t劄: '札',
	s术: '術',
	t術: '术',
	s朴: '樸',
	t樸: '朴',
	s机: '機',
	t機: '机',
	s杀: '殺',
	t殺: '杀',
	s杂: '雜',
	t雜: '杂',
	s权: '權',
	t權: '权',
	s条: '條',
	t條: '条',
	s来: '來',
	t來: '来',
	s杨: '楊',
	t楊: '杨',
	s杩: '榪',
	t榪: '杩',
	s杰: '傑',
	t傑: '杰',
	s极: '極',
	t極: '极',
	s构: '構',
	t構: '构',
	s枞: '樅',
	t樅: '枞',
	s枢: '樞',
	t樞: '枢',
	s枣: '棗',
	t棗: '枣',
	s枥: '櫪',
	t櫪: '枥',
	s枧: '梘',
	t梘: '枧',
	s枨: '棖',
	t棖: '枨',
	s枪: '槍',
	t槍: '枪',
	s枫: '楓',
	t楓: '枫',
	s枭: '梟',
	t梟: '枭',
	s柜: '櫃',
	t櫃: '柜',
	s柠: '檸',
	t檸: '柠',
	s柽: '檉',
	t檉: '柽',
	s栀: '梔',
	t梔: '栀',
	s栅: '柵',
	t柵: '栅',
	s标: '標',
	t標: '标',
	s栈: '棧',
	t棧: '栈',
	s栉: '櫛',
	t櫛: '栉',
	s栊: '櫳',
	t櫳: '栊',
	s栋: '棟',
	t棟: '栋',
	s栌: '櫨',
	t櫨: '栌',
	s栎: '櫟',
	t櫟: '栎',
	s栏: '欄',
	t欄: '栏',
	s树: '樹',
	t樹: '树',
	s栖: '棲',
	t棲: '栖',
	s样: '樣',
	t樣: '样',
	s栾: '欒',
	t欒: '栾',
	s桊: '棬',
	t棬: '桊',
	s桠: '椏',
	t椏: '桠',
	s桡: '橈',
	t橈: '桡',
	s桢: '楨',
	t楨: '桢',
	s档: '檔',
	t檔: '档',
	s桤: '榿',
	t榿: '桤',
	s桥: '橋',
	t橋: '桥',
	s桦: '樺',
	t樺: '桦',
	s桧: '檜',
	t檜: '桧',
	s桨: '槳',
	t槳: '桨',
	s桩: '樁',
	t樁: '桩',
	s梦: '夢',
	t夢: '梦',
	s梼: '檮',
	t檮: '梼',
	s梾: '棶',
	t棶: '梾',
	s检: '檢',
	t檢: '检',
	s棂: '欞',
	t欞: '棂',
	s椁: '槨',
	t槨: '椁',
	s椟: '櫝',
	t櫝: '椟',
	s椠: '槧',
	t槧: '椠',
	s椤: '欏',
	t欏: '椤',
	s椭: '橢',
	t橢: '椭',
	s楼: '樓',
	t樓: '楼',
	s榄: '欖',
	t欖: '榄',
	s榇: '櫬',
	t櫬: '榇',
	s榈: '櫚',
	t櫚: '榈',
	s榉: '櫸',
	t櫸: '榉',
	s槚: '檟',
	t檟: '槚',
	s槛: '檻',
	t檻: '槛',
	s槟: '檳',
	t檳: '槟',
	s槠: '櫧',
	t櫧: '槠',
	s横: '橫',
	t橫: '横',
	s樯: '檣',
	t檣: '樯',
	s樱: '櫻',
	t櫻: '樱',
	s橥: '櫫',
	t櫫: '橥',
	s橱: '櫥',
	t櫥: '橱',
	s橹: '櫓',
	t櫓: '橹',
	s橼: '櫞',
	t櫞: '橼',
	s檐: '簷',
	t簷: '檐',
	s檩: '檁',
	t檁: '檩',
	s欢: '歡',
	t歡: '欢',
	s欤: '歟',
	t歟: '欤',
	s欧: '歐',
	t歐: '欧',
	s歼: '殲',
	t殲: '歼',
	s殁: '歿',
	t歿: '殁',
	s殇: '殤',
	t殤: '殇',
	s残: '殘',
	t殘: '残',
	s殒: '殞',
	t殞: '殒',
	s殓: '殮',
	t殮: '殓',
	s殚: '殫',
	t殫: '殚',
	s殡: '殯',
	t殯: '殡',
	s殴: '毆',
	t毆: '殴',
	s毁: '毀',
	t毀: '毁',
	s毂: '轂',
	t轂: '毂',
	s毕: '畢',
	t畢: '毕',
	s毙: '斃',
	t斃: '毙',
	s毡: '氈',
	t氈: '毡',
	s毵: '毿',
	t毿: '毵',
	s氇: '氌',
	t氌: '氇',
	s气: '氣',
	t氣: '气',
	s氢: '氫',
	t氫: '氢',
	s氩: '氬',
	t氬: '氩',
	s氲: '氳',
	t氳: '氲',
	s汇: '彙',
	t彙: '汇',
	s汉: '漢',
	t漢: '汉',
	s污: '汙',
	t汙: '污',
	s汤: '湯',
	t湯: '汤',
	s汹: '洶',
	t洶: '汹',
	s沓: '遝',
	t遝: '沓',
	s沟: '溝',
	t溝: '沟',
	s没: '冇',
	t沒: '没',
	s沣: '灃',
	t灃: '沣',
	s沤: '漚',
	t漚: '沤',
	s沥: '瀝',
	t瀝: '沥',
	s沦: '淪',
	t淪: '沦',
	s沧: '滄',
	t滄: '沧',
	s沨: '渢',
	t渢: '沨',
	s沩: '溈',
	t溈: '沩',
	s沪: '滬',
	t滬: '沪',
	s沵: '濔',
	t濔: '沵',
	s泞: '濘',
	t濘: '泞',
	s泪: '淚',
	t淚: '泪',
	s泶: '澩',
	t澩: '泶',
	s泷: '瀧',
	t瀧: '泷',
	s泸: '瀘',
	t瀘: '泸',
	s泺: '濼',
	t濼: '泺',
	s泻: '瀉',
	t瀉: '泻',
	s泼: '潑',
	t潑: '泼',
	s泽: '澤',
	t澤: '泽',
	s泾: '涇',
	t涇: '泾',
	s洁: '潔',
	t潔: '洁',
	s洒: '灑',
	t灑: '洒',
	s洼: '窪',
	t窪: '洼',
	s浃: '浹',
	t浹: '浃',
	s浅: '淺',
	t淺: '浅',
	s浆: '漿',
	t漿: '浆',
	s浇: '澆',
	t澆: '浇',
	s浈: '湞',
	t湞: '浈',
	s浉: '溮',
	t溮: '浉',
	s浊: '濁',
	t濁: '浊',
	s测: '測',
	t測: '测',
	s浍: '澮',
	t澮: '浍',
	s济: '濟',
	t濟: '济',
	s浏: '瀏',
	t瀏: '浏',
	s浐: '滻',
	t滻: '浐',
	s浑: '渾',
	t渾: '浑',
	s浒: '滸',
	t滸: '浒',
	s浓: '濃',
	t濃: '浓',
	s浔: '潯',
	t潯: '浔',
	s浕: '濜',
	t濜: '浕',
	s涂: '塗',
	t塗: '涂',
	s涌: '湧',
	t湧: '涌',
	s涛: '濤',
	t濤: '涛',
	s涝: '澇',
	t澇: '涝',
	s涞: '淶',
	t淶: '涞',
	s涟: '漣',
	t漣: '涟',
	s涠: '潿',
	t潿: '涠',
	s涡: '渦',
	t渦: '涡',
	s涢: '溳',
	t溳: '涢',
	s涣: '渙',
	t渙: '涣',
	s涤: '滌',
	t滌: '涤',
	s润: '潤',
	t潤: '润',
	s涧: '澗',
	t澗: '涧',
	s涨: '漲',
	t漲: '涨',
	s涩: '澀',
	t澀: '涩',
	s淀: '澱',
	t澱: '淀',
	s渊: '淵',
	t淵: '渊',
	s渌: '淥',
	t淥: '渌',
	s渍: '漬',
	t漬: '渍',
	s渎: '瀆',
	t瀆: '渎',
	s渐: '漸',
	t漸: '渐',
	s渑: '澠',
	t澠: '渑',
	s渔: '漁',
	t漁: '渔',
	s渖: '瀋',
	t瀋: '渖',
	s渗: '滲',
	t滲: '渗',
	s温: '溫',
	t溫: '温',
	s游: '遊',
	t遊: '游',
	s湾: '灣',
	t灣: '湾',
	s湿: '濕',
	t濕: '湿',
	s溃: '潰',
	t潰: '溃',
	s溅: '濺',
	t濺: '溅',
	s溆: '漵',
	t漵: '溆',
	s溇: '漊',
	t漊: '溇',
	s滗: '潷',
	t潷: '滗',
	s滚: '滾',
	t滾: '磙',
	s滞: '滯',
	t滯: '滞',
	s滟: '灩',
	t灩: '滟',
	s滠: '灄',
	t灄: '滠',
	s满: '滿',
	t滿: '满',
	s滢: '瀅',
	t瀅: '滢',
	s滤: '濾',
	t濾: '滤',
	s滥: '濫',
	t濫: '漤',
	s滦: '灤',
	t灤: '滦',
	s滨: '濱',
	t濱: '滨',
	s滩: '灘',
	t灘: '滩',
	s滪: '澦',
	t澦: '滪',
	s漤: '濫',
	s潆: '瀠',
	t瀠: '潆',
	s潇: '瀟',
	t瀟: '潇',
	s潋: '瀲',
	t瀲: '潋',
	s潍: '濰',
	t濰: '潍',
	s潜: '潛',
	t潛: '潜',
	s潴: '瀦',
	t瀦: '潴',
	s澜: '瀾',
	t瀾: '澜',
	s濑: '瀨',
	t瀨: '濑',
	s濒: '瀕',
	t瀕: '濒',
	s灏: '灝',
	t灝: '灏',
	s灭: '滅',
	t滅: '灭',
	s灯: '燈',
	t燈: '灯',
	s灵: '靈',
	t靈: '灵',
	s灾: '災',
	t災: '灾',
	s灿: '燦',
	t燦: '灿',
	s炀: '煬',
	t煬: '炀',
	s炉: '爐',
	t爐: '炉',
	s炖: '燉',
	t燉: '炖',
	s炜: '煒',
	t煒: '炜',
	s炝: '熗',
	t熗: '炝',
	s点: '點',
	t點: '点',
	s炼: '煉',
	t煉: '炼',
	s炽: '熾',
	t熾: '炽',
	s烁: '爍',
	t爍: '烁',
	s烂: '爛',
	t爛: '烂',
	s烃: '烴',
	t烴: '烃',
	s烛: '燭',
	t燭: '烛',
	s烟: '煙',
	t煙: '烟',
	s烦: '煩',
	t煩: '烦',
	s烧: '燒',
	t燒: '烧',
	s烨: '燁',
	t燁: '烨',
	s烩: '燴',
	t燴: '烩',
	s烫: '燙',
	t燙: '烫',
	s烬: '燼',
	t燼: '烬',
	s热: '熱',
	t熱: '热',
	s焕: '煥',
	t煥: '焕',
	s焖: '燜',
	t燜: '焖',
	s焘: '燾',
	t燾: '焘',
	s煅: '煆',
	t煆: '煅',
	s煳: '糊',
	t糊: '煳',
	s熘: '溜',
	t溜: '熘',
	s爱: '愛',
	t愛: '爱',
	s爷: '爺',
	t爺: '爷',
	s牍: '牘',
	t牘: '牍',
	s牦: '犛',
	t犛: '牦',
	s牵: '牽',
	t牽: '牵',
	s牺: '犧',
	t犧: '牺',
	s犊: '犢',
	t犢: '犊',
	s犟: '強',
	s状: '狀',
	t狀: '状',
	s犷: '獷',
	t獷: '犷',
	s犸: '獁',
	t獁: '犸',
	s犹: '猶',
	t猶: '犹',
	s狈: '狽',
	t狽: '狈',
	s狍: '麅',
	t麅: '狍',
	s狝: '獮',
	t獮: '狝',
	s狞: '獰',
	t獰: '狞',
	s独: '獨',
	t獨: '独',
	s狭: '狹',
	t狹: '狭',
	s狮: '獅',
	t獅: '狮',
	s狯: '獪',
	t獪: '狯',
	s狰: '猙',
	t猙: '狰',
	s狱: '獄',
	t獄: '狱',
	s狲: '猻',
	t猻: '狲',
	s猃: '獫',
	t獫: '猃',
	s猎: '獵',
	t獵: '猎',
	s猕: '獼',
	t獼: '猕',
	s猡: '玀',
	t玀: '猡',
	s猪: '豬',
	t豬: '猪',
	s猫: '貓',
	t貓: '猫',
	s猬: '蝟',
	t蝟: '猬',
	s献: '獻',
	t獻: '献',
	s獭: '獺',
	t獺: '獭',
	s玑: '璣',
	t璣: '玑',
	s玙: '璵',
	t璵: '玙',
	s玚: '瑒',
	t瑒: '玚',
	s玛: '瑪',
	t瑪: '玛',
	s玮: '瑋',
	t瑋: '玮',
	s环: '環',
	t環: '环',
	s现: '現',
	t現: '现',
	s玱: '瑲',
	t瑲: '玱',
	s玺: '璽',
	t璽: '玺',
	s珉: '瑉',
	t瑉: '珉',
	s珏: '玨',
	t玨: '珏',
	s珐: '琺',
	t琺: '珐',
	s珑: '瓏',
	t瓏: '珑',
	s珰: '璫',
	t璫: '珰',
	s珲: '琿',
	t琿: '珲',
	s琎: '璡',
	t璡: '琎',
	s琏: '璉',
	t璉: '琏',
	s琐: '瑣',
	t瑣: '琐',
	s琼: '瓊',
	t瓊: '琼',
	s瑶: '瑤',
	t瑤: '瑶',
	s瑷: '璦',
	t璦: '瑷',
	s璇: '璿',
	t璿: '璇',
	s璎: '瓔',
	t瓔: '璎',
	s瓒: '瓚',
	t瓚: '瓒',
	s瓮: '甕',
	t甕: '瓮',
	s瓯: '甌',
	t甌: '瓯',
	s电: '電',
	t電: '电',
	s画: '畫',
	t畫: '画',
	s畅: '暢',
	t暢: '畅',
	s畲: '佘',
	t佘: '畲',
	s畴: '疇',
	t疇: '畴',
	s疖: '癤',
	t癤: '疖',
	s疗: '療',
	t療: '疗',
	s疟: '瘧',
	t瘧: '疟',
	s疠: '癘',
	t癘: '疠',
	s疡: '瘍',
	t瘍: '疡',
	s疬: '鬁',
	t鬁: '疬',
	s疮: '瘡',
	t瘡: '疮',
	s疯: '瘋',
	t瘋: '疯',
	s疱: '皰',
	t皰: '疱',
	s疴: '屙',
	t屙: '疴',
	s痈: '癰',
	t癰: '痈',
	s痉: '痙',
	t痙: '痉',
	s痒: '癢',
	t癢: '痒',
	s痖: '瘂',
	t瘂: '痖',
	s痨: '癆',
	t癆: '痨',
	s痪: '瘓',
	t瘓: '痪',
	s痫: '癇',
	t癇: '痫',
	s痴: '癡',
	t癡: '痴',
	s瘅: '癉',
	t癉: '瘅',
	s瘆: '瘮',
	t瘮: '瘆',
	s瘗: '瘞',
	t瘞: '瘗',
	s瘘: '瘺',
	t瘺: '瘘',
	s瘪: '癟',
	t癟: '瘪',
	s瘫: '癱',
	t癱: '瘫',
	s瘾: '癮',
	t癮: '瘾',
	s瘿: '癭',
	t癭: '瘿',
	s癞: '癩',
	t癩: '癞',
	s癣: '癬',
	t癬: '癣',
	s癫: '癲',
	t癲: '癫',
	s癯: '臒',
	t臒: '癯',
	s皑: '皚',
	t皚: '皑',
	s皱: '皺',
	t皺: '皱',
	s皲: '皸',
	t皸: '皲',
	s盏: '盞',
	t盞: '盏',
	s盐: '鹽',
	t鹽: '盐',
	s监: '監',
	t監: '监',
	s盖: '蓋',
	t蓋: '盖',
	s盗: '盜',
	t盜: '盗',
	s盘: '盤',
	t盤: '盘',
	s眍: '瞘',
	t瞘: '眍',
	s眦: '眥',
	t眥: '眦',
	s眬: '矓',
	t矓: '眬',
	s着: '著',
	t著: '着',
	s睁: '睜',
	t睜: '睁',
	s睐: '睞',
	t睞: '睐',
	s睑: '瞼',
	t瞼: '睑',
	s瞒: '瞞',
	t瞞: '瞒',
	s瞩: '矚',
	t矚: '瞩',
	s矫: '矯',
	t矯: '矫',
	s矶: '磯',
	t磯: '矶',
	s矾: '礬',
	t礬: '矾',
	s矿: '礦',
	t礦: '矿',
	s砀: '碭',
	t碭: '砀',
	s码: '碼',
	t碼: '码',
	s砖: '磚',
	t磚: '砖',
	s砗: '硨',
	t硨: '砗',
	s砚: '硯',
	t硯: '砚',
	s砜: '碸',
	t碸: '砜',
	s砺: '礪',
	t礪: '砺',
	s砻: '礱',
	t礱: '砻',
	s砾: '礫',
	t礫: '砾',
	s础: '礎',
	t礎: '础',
	s硁: '硜',
	t硜: '硁',
	s硅: '矽',
	t矽: '硅',
	s硕: '碩',
	t碩: '硕',
	s硖: '硤',
	t硤: '硖',
	s硗: '磽',
	t磽: '硗',
	s硙: '磑',
	t磑: '硙',
	s硚: '礄',
	t礄: '硚',
	s确: '確',
	t確: '确',
	s硷: '鹼',
	t鹼: '硷',
	s碍: '礙',
	t礙: '碍',
	s碛: '磧',
	t磧: '碛',
	s碜: '磣',
	t磣: '碜',
	s碱: '堿',
	t堿: '碱',
	s碹: '镟',
	t镟: '碹',
	s磙: '滾',
	s礼: '禮',
	t禮: '礼',
	s祎: '禕',
	t禕: '祎',
	s祢: '禰',
	t禰: '祢',
	s祯: '禎',
	t禎: '祯',
	s祷: '禱',
	t禱: '祷',
	s祸: '禍',
	t禍: '祸',
	s禀: '稟',
	t稟: '禀',
	s禄: '祿',
	t祿: '禄',
	s禅: '禪',
	t禪: '禅',
	s离: '離',
	t離: '离',
	s秃: '禿',
	t禿: '秃',
	s秆: '稈',
	t稈: '秆',
	s种: '種',
	t種: '种',
	s积: '積',
	t積: '积',
	s称: '稱',
	t稱: '称',
	s秽: '穢',
	t穢: '秽',
	s秾: '穠',
	t穠: '秾',
	s稆: '穭',
	t穭: '稆',
	s税: '稅',
	t稅: '税',
	s稣: '穌',
	t穌: '稣',
	s稳: '穩',
	t穩: '稳',
	s穑: '穡',
	t穡: '穑',
	s穷: '窮',
	t窮: '穷',
	s窃: '竊',
	t竊: '窃',
	s窍: '竅',
	t竅: '窍',
	s窑: '窯',
	t窯: '窑',
	s窜: '竄',
	t竄: '窜',
	s窝: '窩',
	t窩: '窝',
	s窥: '窺',
	t窺: '窥',
	s窦: '竇',
	t竇: '窦',
	s窭: '窶',
	t窶: '窭',
	s竖: '豎',
	t豎: '竖',
	s竞: '競',
	t競: '竞',
	s笃: '篤',
	t篤: '笃',
	s笋: '筍',
	t筍: '笋',
	s笔: '筆',
	t筆: '笔',
	s笕: '筧',
	t筧: '笕',
	s笺: '箋',
	t箋: '笺',
	s笼: '籠',
	t籠: '笼',
	s笾: '籩',
	t籩: '笾',
	s筑: '築',
	t築: '筑',
	s筚: '篳',
	t篳: '筚',
	s筛: '篩',
	t篩: '筛',
	s筜: '簹',
	t簹: '筜',
	s筝: '箏',
	t箏: '筝',
	s筹: '籌',
	t籌: '筹',
	s签: '簽',
	t簽: '签',
	s简: '簡',
	t簡: '简',
	s箓: '籙',
	t籙: '箓',
	s箦: '簀',
	t簀: '箦',
	s箧: '篋',
	t篋: '箧',
	s箨: '籜',
	t籜: '箨',
	s箩: '籮',
	t籮: '箩',
	s箪: '簞',
	t簞: '箪',
	s箫: '簫',
	t簫: '箫',
	s篑: '簣',
	t簣: '篑',
	s篓: '簍',
	t簍: '篓',
	s篮: '籃',
	t籃: '篮',
	s篱: '籬',
	t籬: '篱',
	s簖: '籪',
	t籪: '簖',
	s籁: '籟',
	t籟: '籁',
	s籴: '糴',
	t糴: '籴',
	s类: '類',
	t類: '类',
	s籼: '秈',
	t秈: '籼',
	s粜: '糶',
	t糶: '粜',
	s粝: '糲',
	t糲: '粝',
	s粤: '粵',
	t粵: '粤',
	s粪: '糞',
	t糞: '粪',
	s粮: '糧',
	t糧: '粮',
	s糁: '糝',
	t糝: '糁',
	s糇: '餱',
	t餱: '糇',
	s紧: '緊',
	t緊: '紧',
	s絷: '縶',
	t縶: '絷',
	s纟: '糸',
	t糸: '纟',
	s纠: '糾',
	t糾: '纠',
	s纡: '紆',
	t紆: '纡',
	s红: '紅',
	t紅: '红',
	s纣: '紂',
	t紂: '纣',
	s纤: '纖',
	t纖: '纤',
	s纥: '紇',
	t紇: '纥',
	s约: '約',
	t約: '约',
	s级: '級',
	t級: '级',
	s纨: '紈',
	t紈: '纨',
	s纩: '纊',
	t纊: '纩',
	s纪: '紀',
	t紀: '纪',
	s纫: '紉',
	t紉: '纫',
	s纬: '緯',
	t緯: '纬',
	s纭: '紜',
	t紜: '纭',
	s纮: '紘',
	t紘: '纮',
	s纯: '純',
	t純: '纯',
	s纰: '紕',
	t紕: '纰',
	s纱: '紗',
	t紗: '纱',
	s纲: '綱',
	t綱: '纲',
	s纳: '納',
	t納: '纳',
	s纴: '紝',
	t紝: '纴',
	s纵: '縱',
	t縱: '纵',
	s纶: '綸',
	t綸: '纶',
	s纷: '紛',
	t紛: '纷',
	s纸: '紙',
	t紙: '纸',
	s纹: '紋',
	t紋: '纹',
	s纺: '紡',
	t紡: '纺',
	s纻: '紵',
	t紵: '纻',
	s纼: '紖',
	t紖: '纼',
	s纽: '紐',
	t紐: '纽',
	s纾: '紓',
	t紓: '纾',
	s线: '線',
	t線: '缐',
	s绀: '紺',
	t紺: '绀',
	s绁: '絏',
	t絏: '绁',
	s绂: '紱',
	t紱: '绂',
	s练: '練',
	t練: '练',
	s组: '組',
	t組: '组',
	s绅: '紳',
	t紳: '绅',
	s细: '細',
	t細: '细',
	s织: '織',
	t織: '织',
	s终: '終',
	t終: '终',
	s绉: '縐',
	t縐: '绉',
	s绊: '絆',
	t絆: '绊',
	s绋: '紼',
	t紼: '绋',
	s绌: '絀',
	t絀: '绌',
	s绍: '紹',
	t紹: '绍',
	s绎: '繹',
	t繹: '绎',
	s经: '經',
	t經: '经',
	s绐: '紿',
	t紿: '绐',
	s绑: '綁',
	t綁: '绑',
	s绒: '絨',
	t絨: '绒',
	s结: '結',
	t結: '结',
	s绔: '絝',
	t絝: '绔',
	s绕: '繞',
	t繞: '绕',
	s绖: '絰',
	t絰: '绖',
	s绗: '絎',
	t絎: '绗',
	s绘: '繪',
	t繪: '绘',
	s给: '給',
	t給: '给',
	s绚: '絢',
	t絢: '绚',
	s绛: '絳',
	t絳: '绛',
	s络: '絡',
	t絡: '络',
	s绝: '絕',
	t絕: '绝',
	s绞: '絞',
	t絞: '绞',
	s统: '統',
	t統: '统',
	s绠: '綆',
	t綆: '绠',
	s绡: '綃',
	t綃: '绡',
	s绢: '絹',
	t絹: '绢',
	s绣: '繡',
	t繡: '绣',
	s绤: '綌',
	t綌: '绤',
	s绥: '綏',
	t綏: '绥',
	s绦: '絛',
	t絛: '绦',
	s继: '繼',
	t繼: '继',
	s绨: '綈',
	t綈: '绨',
	s绩: '績',
	t績: '绩',
	s绪: '緒',
	t緒: '绪',
	s绫: '綾',
	t綾: '绫',
	s绬: '緓',
	t緓: '绬',
	s续: '續',
	t續: '续',
	s绮: '綺',
	t綺: '绮',
	s绯: '緋',
	t緋: '绯',
	s绰: '綽',
	t綽: '绰',
	s绱: '緔',
	t緔: '绱',
	s绲: '緄',
	t緄: '绲',
	s绳: '繩',
	t繩: '绳',
	s维: '維',
	t維: '维',
	s绵: '綿',
	t綿: '绵',
	s绶: '綬',
	t綬: '绶',
	s绷: '繃',
	t繃: '绷',
	s绸: '綢',
	t綢: '绸',
	s绹: '綯',
	t綯: '绹',
	s绺: '綹',
	t綹: '绺',
	s绻: '綣',
	t綣: '绻',
	s综: '綜',
	t綜: '综',
	s绽: '綻',
	t綻: '绽',
	s绾: '綰',
	t綰: '绾',
	s绿: '綠',
	t綠: '绿',
	s缀: '綴',
	t綴: '缀',
	s缁: '緇',
	t緇: '缁',
	s缂: '緙',
	t緙: '缂',
	s缃: '緗',
	t緗: '缃',
	s缄: '緘',
	t緘: '缄',
	s缅: '緬',
	t緬: '缅',
	s缆: '纜',
	t纜: '缆',
	s缇: '緹',
	t緹: '缇',
	s缈: '緲',
	t緲: '缈',
	s缉: '緝',
	t緝: '缉',
	s缊: '縕',
	t縕: '缊',
	s缋: '繢',
	t繢: '缋',
	s缌: '緦',
	t緦: '缌',
	s缍: '綞',
	t綞: '缍',
	s缎: '緞',
	t緞: '缎',
	s缏: '緶',
	t緶: '缏',
	s缐: '線',
	s缑: '緱',
	t緱: '缑',
	s缒: '縋',
	t縋: '缒',
	s缓: '緩',
	t緩: '缓',
	s缔: '締',
	t締: '缔',
	s缕: '縷',
	t縷: '缕',
	s编: '編',
	t編: '编',
	s缗: '緡',
	t緡: '缗',
	s缘: '緣',
	t緣: '缘',
	s缙: '縉',
	t縉: '缙',
	s缚: '縛',
	t縛: '缚',
	s缛: '縟',
	t縟: '缛',
	s缜: '縝',
	t縝: '缜',
	s缝: '縫',
	t縫: '缝',
	s缞: '縗',
	t縗: '缞',
	s缟: '縞',
	t縞: '缟',
	s缠: '纏',
	t纏: '缠',
	s缡: '縭',
	t縭: '缡',
	s缢: '縊',
	t縊: '缢',
	s缣: '縑',
	t縑: '缣',
	s缤: '繽',
	t繽: '缤',
	s缥: '縹',
	t縹: '缥',
	s缦: '縵',
	t縵: '缦',
	s缧: '縲',
	t縲: '缧',
	s缨: '纓',
	t纓: '缨',
	s缩: '縮',
	t縮: '缩',
	s缪: '繆',
	t繆: '缪',
	s缫: '繅',
	t繅: '缫',
	s缬: '纈',
	t纈: '缬',
	s缭: '繚',
	t繚: '缭',
	s缮: '繕',
	t繕: '缮',
	s缯: '繒',
	t繒: '缯',
	s缰: '韁',
	t韁: '缰',
	s缱: '繾',
	t繾: '缱',
	s缲: '繰',
	t繰: '缲',
	s缳: '繯',
	t繯: '缳',
	s缴: '繳',
	t繳: '缴',
	s缵: '纘',
	t纘: '缵',
	s罂: '罌',
	t罌: '罂',
	s网: '網',
	t網: '网',
	s罗: '羅',
	t羅: '罗',
	s罚: '罰',
	t罰: '罚',
	s罢: '罷',
	t罷: '罢',
	s罴: '羆',
	t羆: '罴',
	s羁: '羈',
	t羈: '羁',
	s羟: '羥',
	t羥: '羟',
	s羡: '羨',
	t羨: '羡',
	s翘: '翹',
	t翹: '翘',
	s翙: '翽',
	t翽: '翙',
	s翚: '翬',
	t翬: '翚',
	s耢: '耮',
	t耮: '耢',
	s耧: '耬',
	t耬: '耧',
	s耸: '聳',
	t聳: '耸',
	s耻: '恥',
	t恥: '耻',
	s聂: '聶',
	t聶: '聂',
	s聋: '聾',
	t聾: '聋',
	s职: '職',
	t職: '职',
	s聍: '聹',
	t聹: '聍',
	s联: '聯',
	t聯: '联',
	s聩: '聵',
	t聵: '聩',
	s聪: '聰',
	t聰: '聪',
	s肃: '肅',
	t肅: '肃',
	s肠: '腸',
	t腸: '肠',
	s肤: '膚',
	t膚: '肤',
	s肷: '膁',
	t膁: '肷',
	s肾: '腎',
	t腎: '肾',
	s肿: '腫',
	t腫: '肿',
	s胀: '脹',
	t脹: '胀',
	s胁: '脅',
	t脅: '胁',
	s胆: '膽',
	t膽: '胆',
	s胜: '勝',
	t勝: '胜',
	s胧: '朧',
	t朧: '胧',
	s胨: '腖',
	t腖: '胨',
	s胪: '臚',
	t臚: '胪',
	s胫: '脛',
	t脛: '胫',
	s胶: '膠',
	t膠: '胶',
	s脉: '脈',
	t脈: '脉',
	s脍: '膾',
	t膾: '脍',
	s脏: '臟',
	t髒: '脏',
	s脐: '臍',
	t臍: '脐',
	s脑: '腦',
	t腦: '脑',
	s脓: '膿',
	t膿: '脓',
	s脔: '臠',
	t臠: '脔',
	s脚: '腳',
	t腳: '脚',
	s脱: '脫',
	t脫: '脱',
	s脶: '腡',
	t腡: '脶',
	s脸: '臉',
	t臉: '脸',
	s腊: '臘',
	t臘: '腊',
	s腌: '醃',
	t醃: '腌',
	s腘: '膕',
	t膕: '腘',
	s腭: '齶',
	t齶: '腭',
	s腻: '膩',
	t膩: '腻',
	s腼: '靦',
	t靦: '腼',
	s腽: '膃',
	t膃: '腽',
	s腾: '騰',
	t騰: '腾',
	s膑: '臏',
	t臏: '膑',
	s臜: '臢',
	t臢: '臜',
	s舆: '輿',
	t輿: '舆',
	s舣: '艤',
	t艤: '舣',
	s舰: '艦',
	t艦: '舰',
	s舱: '艙',
	t艙: '舱',
	s舻: '艫',
	t艫: '舻',
	s艰: '艱',
	t艱: '艰',
	s艳: '豔',
	t豔: '艳',
	s艹: '艸',
	t艸: '艹',
	s艺: '藝',
	t藝: '艺',
	s节: '節',
	t節: '节',
	s芈: '羋',
	t羋: '芈',
	s芗: '薌',
	t薌: '芗',
	s芜: '蕪',
	t蕪: '芜',
	s芦: '蘆',
	t蘆: '芦',
	s苁: '蓯',
	t蓯: '苁',
	s苇: '葦',
	t葦: '苇',
	s苈: '藶',
	t藶: '苈',
	s苋: '莧',
	t莧: '苋',
	s苌: '萇',
	t萇: '苌',
	s苍: '蒼',
	t蒼: '苍',
	s苎: '苧',
	t苧: '苎',
	s苏: '蘇',
	t蘇: '苏',
	s苘: '檾',
	t檾: '苘',
	s苹: '蘋',
	t蘋: '苹',
	s茎: '莖',
	t莖: '茎',
	s茏: '蘢',
	t蘢: '茏',
	s茑: '蔦',
	t蔦: '茑',
	s茔: '塋',
	t塋: '茔',
	s茕: '煢',
	t煢: '茕',
	s茧: '繭',
	t繭: '茧',
	s荆: '荊',
	t荊: '荆',
	s荐: '薦',
	t薦: '荐',
	s荙: '薘',
	t薘: '荙',
	s荚: '莢',
	t莢: '荚',
	s荛: '蕘',
	t蕘: '荛',
	s荜: '蓽',
	t蓽: '荜',
	s荞: '蕎',
	t蕎: '荞',
	s荟: '薈',
	t薈: '荟',
	s荠: '薺',
	t薺: '荠',
	s荡: '蕩',
	t蕩: '荡',
	s荣: '榮',
	t榮: '荣',
	s荤: '葷',
	t葷: '荤',
	s荥: '滎',
	t滎: '荥',
	s荦: '犖',
	t犖: '荦',
	s荧: '熒',
	t熒: '荧',
	s荨: '蕁',
	t蕁: '荨',
	s荩: '藎',
	t藎: '荩',
	s荪: '蓀',
	t蓀: '荪',
	s荫: '蔭',
	t蔭: '荫',
	s荬: '蕒',
	t蕒: '荬',
	s荭: '葒',
	t葒: '荭',
	s荮: '葤',
	t葤: '荮',
	s药: '藥',
	t藥: '药',
	s莅: '蒞',
	t蒞: '莅',
	s莜: '蓧',
	t蓧: '莜',
	s莱: '萊',
	t萊: '莱',
	s莲: '蓮',
	t蓮: '莲',
	s莳: '蒔',
	t蒔: '莳',
	s莴: '萵',
	t萵: '莴',
	s莶: '薟',
	t薟: '莶',
	s获: '獲',
	t獲: '获',
	s莸: '蕕',
	t蕕: '莸',
	s莹: '瑩',
	t瑩: '莹',
	s莺: '鶯',
	t鶯: '莺',
	s莼: '蓴',
	t蓴: '莼',
	s萚: '蘀',
	t蘀: '萚',
	s萝: '蘿',
	t蘿: '萝',
	s萤: '螢',
	t螢: '萤',
	s营: '營',
	t營: '营',
	s萦: '縈',
	t縈: '萦',
	s萧: '蕭',
	t蕭: '萧',
	s萨: '薩',
	t薩: '萨',
	s葱: '蔥',
	t蔥: '葱',
	s蒇: '蕆',
	t蕆: '蒇',
	s蒉: '蕢',
	t蕢: '蒉',
	s蒋: '蔣',
	t蔣: '蒋',
	s蒌: '蔞',
	t蔞: '蒌',
	s蓝: '藍',
	t藍: '蓝',
	s蓟: '薊',
	t薊: '蓟',
	s蓠: '蘺',
	t蘺: '蓠',
	s蓣: '蕷',
	t蕷: '蓣',
	s蓥: '鎣',
	t鎣: '蓥',
	s蓦: '驀',
	t驀: '蓦',
	s蔷: '薔',
	t薔: '蔷',
	s蔹: '蘞',
	t蘞: '蔹',
	s蔺: '藺',
	t藺: '蔺',
	s蔼: '藹',
	t藹: '蔼',
	s蕲: '蘄',
	t蘄: '蕲',
	s蕴: '蘊',
	t蘊: '蕴',
	s薮: '藪',
	t藪: '薮',
	s藁: '槁',
	t槁: '藁',
	s藓: '蘚',
	t蘚: '藓',
	s虏: '虜',
	t虜: '虏',
	s虑: '慮',
	t慮: '虑',
	s虚: '虛',
	t虛: '虚',
	s虫: '蟲',
	t蟲: '虫',
	s虬: '虯',
	t虯: '虬',
	s虮: '蟣',
	t蟣: '虮',
	s虽: '雖',
	t雖: '虽',
	s虾: '蝦',
	t蝦: '虾',
	s虿: '蠆',
	t蠆: '虿',
	s蚀: '蝕',
	t蝕: '蚀',
	s蚁: '蟻',
	t蟻: '蚁',
	s蚂: '螞',
	t螞: '蚂',
	s蚕: '蠶',
	t蠶: '蚕',
	s蚝: '蠔',
	t蠔: '蚝',
	s蚬: '蜆',
	t蜆: '蚬',
	s蛊: '蠱',
	t蠱: '蛊',
	s蛎: '蠣',
	t蠣: '蛎',
	s蛏: '蟶',
	t蟶: '蛏',
	s蛮: '蠻',
	t蠻: '蛮',
	s蛰: '蟄',
	t蟄: '蛰',
	s蛱: '蛺',
	t蛺: '蛱',
	s蛲: '蟯',
	t蟯: '蛲',
	s蛳: '螄',
	t螄: '蛳',
	s蛴: '蠐',
	t蠐: '蛴',
	s蜕: '蛻',
	t蛻: '蜕',
	s蜗: '蝸',
	t蝸: '蜗',
	s蜡: '蠟',
	t蠟: '蜡',
	s蝇: '蠅',
	t蠅: '蝇',
	s蝈: '蟈',
	t蟈: '蝈',
	s蝉: '蟬',
	t蟬: '蝉',
	s蝎: '蠍',
	t蠍: '蝎',
	s蝼: '螻',
	t螻: '蝼',
	s蝾: '蠑',
	t蠑: '蝾',
	s螀: '螿',
	t螿: '螀',
	s螨: '蟎',
	t蟎: '螨',
	s蟏: '蠨',
	t蠨: '蟏',
	s衅: '釁',
	t釁: '衅',
	s衔: '銜',
	t銜: '衔',
	s补: '補',
	t補: '补',
	s衬: '襯',
	t襯: '衬',
	s衮: '袞',
	t袞: '衮',
	s袄: '襖',
	t襖: '袄',
	s袅: '嫋',
	t嫋: '袅',
	s袆: '褘',
	t褘: '袆',
	s袜: '襪',
	t襪: '袜',
	s袭: '襲',
	t襲: '袭',
	s袯: '襏',
	t襏: '袯',
	s装: '裝',
	t裝: '装',
	s裆: '襠',
	t襠: '裆',
	s裈: '褌',
	t褌: '裈',
	s裢: '褳',
	t褳: '裢',
	s裣: '襝',
	t襝: '裣',
	s裤: '褲',
	t褲: '裤',
	s裥: '襇',
	t襇: '裥',
	s褛: '褸',
	t褸: '褛',
	s褴: '襤',
	t襤: '褴',
	s襁: '繈',
	t繈: '襁',
	s襕: '襴',
	t襴: '襕',
	s见: '見',
	t見: '见',
	s观: '觀',
	t觀: '观',
	s觃: '覎',
	t覎: '觃',
	s规: '規',
	t規: '规',
	s觅: '覓',
	t覓: '觅',
	s视: '視',
	t視: '视',
	s觇: '覘',
	t覘: '觇',
	s览: '覽',
	t覽: '览',
	s觉: '覺',
	t覺: '觉',
	s觊: '覬',
	t覬: '觊',
	s觋: '覡',
	t覡: '觋',
	s觌: '覿',
	t覿: '觌',
	s觍: '覥',
	t覥: '觍',
	s觎: '覦',
	t覦: '觎',
	s觏: '覯',
	t覯: '觏',
	s觐: '覲',
	t覲: '觐',
	s觑: '覷',
	t覷: '觑',
	s觞: '觴',
	t觴: '觞',
	s触: '觸',
	t觸: '触',
	s觯: '觶',
	t觶: '觯',
	s詟: '讋',
	t讋: '詟',
	s誉: '譽',
	t譽: '誉',
	s誊: '謄',
	t謄: '誊',
	s讠: '訁',
	t訁: '讠',
	s计: '計',
	t計: '计',
	s订: '訂',
	t訂: '订',
	s讣: '訃',
	t訃: '讣',
	s认: '認',
	t認: '认',
	s讥: '譏',
	t譏: '讥',
	s讦: '訐',
	t訐: '讦',
	s讧: '訌',
	t訌: '讧',
	s讨: '討',
	t討: '讨',
	s让: '讓',
	t讓: '让',
	s讪: '訕',
	t訕: '讪',
	s讫: '訖',
	t訖: '讫',
	s训: '訓',
	t訓: '训',
	s议: '議',
	t議: '议',
	s讯: '訊',
	t訊: '讯',
	s记: '記',
	t記: '记',
	s讱: '訒',
	t訒: '讱',
	s讲: '講',
	t講: '讲',
	s讳: '諱',
	t諱: '讳',
	s讴: '謳',
	t謳: '讴',
	s讵: '詎',
	t詎: '讵',
	s讶: '訝',
	t訝: '讶',
	s讷: '訥',
	t訥: '讷',
	s许: '許',
	t許: '许',
	s讹: '訛',
	t訛: '讹',
	s论: '論',
	t論: '论',
	s讻: '訩',
	t訩: '讻',
	s讼: '訟',
	t訟: '讼',
	s讽: '諷',
	t諷: '讽',
	s设: '設',
	t設: '设',
	s访: '訪',
	t訪: '访',
	s诀: '訣',
	t訣: '诀',
	s证: '證',
	t證: '证',
	s诂: '詁',
	t詁: '诂',
	s诃: '訶',
	t訶: '诃',
	s评: '評',
	t評: '评',
	s诅: '詛',
	t詛: '诅',
	s识: '識',
	t識: '识',
	s诇: '詗',
	t詗: '诇',
	s诈: '詐',
	t詐: '诈',
	s诉: '訴',
	t訴: '诉',
	s诊: '診',
	t診: '诊',
	s诋: '詆',
	t詆: '诋',
	s诌: '謅',
	t謅: '诌',
	s词: '詞',
	t詞: '词',
	s诎: '詘',
	t詘: '诎',
	s诏: '詔',
	t詔: '诏',
	s诐: '詖',
	t詖: '诐',
	s译: '譯',
	t譯: '译',
	s诒: '詒',
	t詒: '诒',
	s诓: '誆',
	t誆: '诓',
	s诔: '誄',
	t誄: '诔',
	s试: '試',
	t試: '试',
	s诖: '詿',
	t詿: '诖',
	s诗: '詩',
	t詩: '诗',
	s诘: '詰',
	t詰: '诘',
	s诙: '詼',
	t詼: '诙',
	s诚: '誠',
	t誠: '诚',
	s诛: '誅',
	t誅: '诛',
	s诜: '詵',
	t詵: '诜',
	s话: '話',
	t話: '话',
	s诞: '誕',
	t誕: '诞',
	s诟: '詬',
	t詬: '诟',
	s诠: '詮',
	t詮: '诠',
	s诡: '詭',
	t詭: '诡',
	s询: '詢',
	t詢: '询',
	s诣: '詣',
	t詣: '诣',
	s诤: '諍',
	t諍: '诤',
	s该: '該',
	t該: '该',
	s详: '詳',
	t詳: '详',
	s诧: '詫',
	t詫: '诧',
	s诨: '諢',
	t諢: '诨',
	s诩: '詡',
	t詡: '诩',
	s诪: '譸',
	t譸: '诪',
	s诫: '誡',
	t誡: '诫',
	s诬: '誣',
	t誣: '诬',
	s语: '語',
	t語: '语',
	s诮: '誚',
	t誚: '诮',
	s误: '誤',
	t誤: '误',
	s诰: '誥',
	t誥: '诰',
	s诱: '誘',
	t誘: '诱',
	s诲: '誨',
	t誨: '诲',
	s诳: '誑',
	t誑: '诳',
	s说: '說',
	t說: '说',
	s诵: '誦',
	t誦: '诵',
	s诶: '誒',
	t誒: '诶',
	s请: '請',
	t請: '请',
	s诸: '諸',
	t諸: '诸',
	s诹: '諏',
	t諏: '诹',
	s诺: '諾',
	t諾: '诺',
	s读: '讀',
	t讀: '读',
	s诼: '諑',
	t諑: '诼',
	s诽: '誹',
	t誹: '诽',
	s课: '課',
	t課: '课',
	s诿: '諉',
	t諉: '诿',
	s谀: '諛',
	t諛: '谀',
	s谁: '誰',
	t誰: '谁',
	s谂: '諗',
	t諗: '谂',
	s调: '調',
	t調: '调',
	s谄: '諂',
	t諂: '谄',
	s谅: '諒',
	t諒: '谅',
	s谆: '諄',
	t諄: '谆',
	s谇: '誶',
	t誶: '谇',
	s谈: '談',
	t談: '谈',
	s谊: '誼',
	t誼: '谊',
	s谋: '謀',
	t謀: '谋',
	s谌: '諶',
	t諶: '谌',
	s谍: '諜',
	t諜: '谍',
	s谎: '謊',
	t謊: '谎',
	s谏: '諫',
	t諫: '谏',
	s谐: '諧',
	t諧: '谐',
	s谑: '謔',
	s谒: '謁',
	t謁: '谒',
	s谓: '謂',
	t謂: '谓',
	s谔: '諤',
	t諤: '谔',
	s谕: '諭',
	t諭: '谕',
	s谖: '諼',
	t諼: '谖',
	s谗: '讒',
	t讒: '谗',
	s谘: '諮',
	t諮: '谘',
	s谙: '諳',
	t諳: '谙',
	s谚: '諺',
	t諺: '谚',
	s谛: '諦',
	t諦: '谛',
	s谜: '謎',
	t謎: '谜',
	s谝: '諞',
	t諞: '谝',
	s谞: '諝',
	t諝: '谞',
	s谟: '謨',
	t謨: '谟',
	s谠: '讜',
	t讜: '谠',
	s谡: '謖',
	t謖: '谡',
	s谢: '謝',
	t謝: '谢',
	s谣: '謠',
	t謠: '谣',
	s谤: '謗',
	t謗: '谤',
	s谥: '諡',
	t諡: '谥',
	s谦: '謙',
	t謙: '谦',
	s谧: '謐',
	t謐: '谧',
	s谨: '謹',
	t謹: '谨',
	s谩: '謾',
	t謾: '谩',
	s谪: '謫',
	t謫: '谪',
	s谫: '譾',
	t譾: '谫',
	s谬: '謬',
	t謬: '谬',
	s谭: '譚',
	t譚: '谭',
	s谮: '譖',
	t譖: '谮',
	s谯: '譙',
	t譙: '谯',
	s谰: '讕',
	t讕: '谰',
	s谱: '譜',
	t譜: '谱',
	s谲: '譎',
	t譎: '谲',
	s谳: '讞',
	t讞: '谳',
	s谴: '譴',
	t譴: '谴',
	s谵: '譫',
	t譫: '谵',
	s谶: '讖',
	t讖: '谶',
	s谷: '穀',
	t穀: '谷',
	s豮: '豶',
	t豶: '豮',
	s贝: '貝',
	t貝: '贝',
	s贞: '貞',
	t貞: '贞',
	s负: '負',
	t負: '负',
	s贠: '貟',
	t貟: '贠',
	s贡: '貢',
	t貢: '贡',
	s财: '財',
	t財: '财',
	s责: '責',
	t責: '责',
	s贤: '賢',
	t賢: '贤',
	s败: '敗',
	t敗: '败',
	s账: '賬',
	t賬: '账',
	s货: '貨',
	t貨: '货',
	s质: '質',
	t質: '质',
	s贩: '販',
	t販: '贩',
	s贪: '貪',
	t貪: '贪',
	s贫: '貧',
	t貧: '贫',
	s贬: '貶',
	t貶: '贬',
	s购: '購',
	t購: '购',
	s贮: '貯',
	t貯: '贮',
	s贯: '貫',
	t貫: '贯',
	s贰: '貳',
	t貳: '贰',
	s贱: '賤',
	t賤: '贱',
	s贲: '賁',
	t賁: '贲',
	s贳: '貰',
	t貰: '贳',
	s贴: '貼',
	t貼: '贴',
	s贵: '貴',
	t貴: '贵',
	s贶: '貺',
	t貺: '贶',
	s贷: '貸',
	t貸: '贷',
	s贸: '貿',
	t貿: '贸',
	s费: '費',
	t費: '费',
	s贺: '賀',
	t賀: '贺',
	s贻: '貽',
	t貽: '贻',
	s贼: '賊',
	t賊: '贼',
	s贽: '贄',
	t贄: '贽',
	s贾: '賈',
	t賈: '贾',
	s贿: '賄',
	t賄: '贿',
	s赀: '貲',
	t貲: '赀',
	s赁: '賃',
	t賃: '赁',
	s赂: '賂',
	t賂: '赂',
	s赃: '贓',
	t贓: '赃',
	s资: '資',
	t資: '资',
	s赅: '賅',
	t賅: '赅',
	s赆: '贐',
	t贐: '赆',
	s赇: '賕',
	t賕: '赇',
	s赈: '賑',
	t賑: '赈',
	s赉: '賚',
	t賚: '赉',
	s赊: '賒',
	t賒: '赊',
	s赋: '賦',
	t賦: '赋',
	s赌: '賭',
	t賭: '赌',
	s赍: '齎',
	t齎: '赍',
	s赎: '贖',
	t贖: '赎',
	s赏: '賞',
	t賞: '赏',
	s赐: '賜',
	t賜: '赐',
	s赑: '贔',
	t贔: '赑',
	s赒: '賙',
	t賙: '赒',
	s赓: '賡',
	t賡: '赓',
	s赔: '賠',
	t賠: '赔',
	s赕: '賧',
	t賧: '赕',
	s赖: '賴',
	t賴: '赖',
	s赗: '賵',
	t賵: '赗',
	s赘: '贅',
	t贅: '赘',
	s赙: '賻',
	t賻: '赙',
	s赚: '賺',
	t賺: '赚',
	s赛: '賽',
	t賽: '赛',
	s赜: '賾',
	t賾: '赜',
	s赝: '贗',
	t贗: '赝',
	s赞: '讚',
	t讚: '赞',
	s赟: '贇',
	t贇: '赟',
	s赠: '贈',
	t贈: '赠',
	s赡: '贍',
	t贍: '赡',
	s赢: '贏',
	t贏: '赢',
	s赣: '贛',
	t贛: '赣',
	s赪: '赬',
	t赬: '赪',
	s赵: '趙',
	t趙: '赵',
	s赶: '趕',
	t趕: '赶',
	s趋: '趨',
	t趨: '趋',
	s趱: '趲',
	t趲: '趱',
	s趸: '躉',
	t躉: '趸',
	s跃: '躍',
	t躍: '跃',
	s跄: '蹌',
	t蹌: '跄',
	s跖: '蹠',
	t蹠: '跖',
	s跞: '躒',
	t躒: '跞',
	s践: '踐',
	t踐: '践',
	s跶: '躂',
	t躂: '跶',
	s跷: '蹺',
	t蹺: '跷',
	s跸: '蹕',
	t蹕: '跸',
	s跹: '躚',
	t躚: '跹',
	s跻: '躋',
	t躋: '跻',
	s踊: '踴',
	t踴: '踊',
	s踌: '躊',
	t躊: '踌',
	s踪: '蹤',
	t蹤: '踪',
	s踬: '躓',
	t躓: '踬',
	s踯: '躑',
	t躑: '踯',
	s蹑: '躡',
	t躡: '蹑',
	s蹒: '蹣',
	t蹣: '蹒',
	s蹰: '躕',
	t躕: '蹰',
	s蹿: '躥',
	t躥: '蹿',
	s躏: '躪',
	t躪: '躏',
	s躜: '躦',
	t躦: '躜',
	s躯: '軀',
	t軀: '躯',
	s车: '車',
	t車: '车',
	s轧: '軋',
	t軋: '轧',
	s轨: '軌',
	t軌: '轨',
	s轩: '軒',
	t軒: '轩',
	s轪: '軑',
	t軑: '轪',
	s轫: '軔',
	t軔: '轫',
	s转: '轉',
	t轉: '转',
	s轭: '軛',
	t軛: '轭',
	s轮: '輪',
	t輪: '轮',
	s软: '軟',
	t軟: '软',
	s轰: '轟',
	t轟: '轰',
	s轱: '軲',
	t軲: '轱',
	s轲: '軻',
	t軻: '轲',
	s轳: '轤',
	t轤: '轳',
	s轴: '軸',
	t軸: '轴',
	s轵: '軹',
	t軹: '轵',
	s轶: '軼',
	t軼: '轶',
	s轷: '軤',
	t軤: '轷',
	s轸: '軫',
	t軫: '轸',
	s轹: '轢',
	t轢: '轹',
	s轺: '軺',
	t軺: '轺',
	s轻: '輕',
	t輕: '轻',
	s轼: '軾',
	t軾: '轼',
	s载: '載',
	t載: '载',
	s轾: '輊',
	t輊: '轾',
	s轿: '轎',
	t轎: '轿',
	s辀: '輈',
	t輈: '辀',
	s辁: '輇',
	t輇: '辁',
	s辂: '輅',
	t輅: '辂',
	s较: '較',
	t較: '较',
	s辄: '輒',
	t輒: '辄',
	s辅: '輔',
	t輔: '辅',
	s辆: '輛',
	t輛: '辆',
	s辇: '輦',
	t輦: '辇',
	s辈: '輩',
	t輩: '辈',
	s辉: '輝',
	t輝: '辉',
	s辊: '輥',
	t輥: '辊',
	s辋: '輞',
	t輞: '辋',
	s辌: '輬',
	t輬: '辌',
	s辍: '輟',
	t輟: '辍',
	s辎: '輜',
	t輜: '辎',
	s辏: '輳',
	t輳: '辏',
	s辐: '輻',
	t輻: '辐',
	s辑: '輯',
	t輯: '辑',
	s辒: '轀',
	t轀: '辒',
	s输: '輸',
	t輸: '输',
	s辔: '轡',
	t轡: '辔',
	s辕: '轅',
	t轅: '辕',
	s辖: '轄',
	t轄: '辖',
	s辗: '輾',
	t輾: '辗',
	s辘: '轆',
	t轆: '辘',
	s辙: '轍',
	t轍: '辙',
	s辚: '轔',
	t轔: '辚',
	s辞: '辭',
	t辭: '辞',
	s辩: '辯',
	t辯: '辩',
	s辫: '辮',
	t辮: '辫',
	s边: '邊',
	t邊: '边',
	s辽: '遼',
	t遼: '辽',
	s达: '達',
	t達: '达',
	s迁: '遷',
	t遷: '迁',
	s过: '過',
	t過: '过',
	s迈: '邁',
	t邁: '迈',
	s运: '運',
	t運: '运',
	s还: '還',
	t還: '还',
	s这: '這',
	t這: '这',
	s进: '進',
	t進: '进',
	s远: '遠',
	t遠: '远',
	s违: '違',
	t違: '违',
	s连: '連',
	t連: '连',
	s迟: '遲',
	t遲: '迟',
	s迩: '邇',
	t邇: '迩',
	s迳: '逕',
	t逕: '迳',
	s迹: '跡',
	t跡: '迹',
	s适: '適',
	t適: '适',
	s选: '選',
	t選: '选',
	s逊: '遜',
	t遜: '逊',
	s递: '遞',
	t遞: '递',
	s逦: '邐',
	t邐: '逦',
	s逻: '邏',
	t邏: '逻',
	s遗: '遺',
	t遺: '遗',
	s遥: '遙',
	t遙: '遥',
	s邓: '鄧',
	t鄧: '邓',
	s邝: '鄺',
	t鄺: '邝',
	s邬: '鄔',
	t鄔: '邬',
	s邮: '郵',
	t郵: '邮',
	s邹: '鄒',
	t鄒: '邹',
	s邺: '鄴',
	t鄴: '邺',
	s邻: '鄰',
	t鄰: '邻',
	s郁: '鬱',
	t鬱: '郁',
	s郄: '郤',
	t郤: '郄',
	s郏: '郟',
	t郟: '郏',
	s郐: '鄶',
	t鄶: '郐',
	s郑: '鄭',
	t鄭: '郑',
	s郓: '鄆',
	t鄆: '郓',
	s郦: '酈',
	t酈: '郦',
	s郧: '鄖',
	t鄖: '郧',
	s郸: '鄲',
	t鄲: '郸',
	s酝: '醞',
	t醞: '酝',
	s酦: '醱',
	t醱: '酦',
	s酱: '醬',
	t醬: '酱',
	s酽: '釅',
	t釅: '酽',
	s酾: '釃',
	t釃: '酾',
	s酿: '釀',
	t釀: '酿',
	s释: '釋',
	t釋: '释',
	s里: '裡',
	t裏: '里',
	s鉅: '钜',
	t钜: '鉅',
	s鉴: '鑒',
	t鑒: '鉴',
	s銮: '鑾',
	t鑾: '銮',
	s錾: '鏨',
	t鏨: '錾',
	s钆: '釓',
	t釓: '钆',
	s钇: '釔',
	t釔: '钇',
	s针: '針',
	t針: '针',
	s钉: '釘',
	t釘: '钉',
	s钊: '釗',
	t釗: '钊',
	s钋: '釙',
	t釙: '钋',
	s钌: '釕',
	t釕: '钌',
	s钍: '釷',
	t釷: '钍',
	s钎: '釺',
	t釺: '钎',
	s钏: '釧',
	t釧: '钏',
	s钐: '釤',
	t釤: '钐',
	s钑: '鈒',
	t鈒: '钑',
	s钒: '釩',
	t釩: '钒',
	s钓: '釣',
	t釣: '钓',
	s钔: '鍆',
	t鍆: '钔',
	s钕: '釹',
	t釹: '钕',
	s钖: '鍚',
	t鍚: '钖',
	s钗: '釵',
	t釵: '钗',
	s钘: '鈃',
	t鈃: '钘',
	s钙: '鈣',
	t鈣: '钙',
	s钚: '鈈',
	t鈈: '钚',
	s钛: '鈦',
	t鈦: '钛',
	s钝: '鈍',
	t鈍: '钝',
	s钞: '鈔',
	t鈔: '钞',
	s钟: '鐘',
	t鍾: '锺',
	s钠: '鈉',
	t鈉: '钠',
	s钡: '鋇',
	t鋇: '钡',
	s钢: '鋼',
	t鋼: '钢',
	s钣: '鈑',
	t鈑: '钣',
	s钤: '鈐',
	t鈐: '钤',
	s钥: '鑰',
	t鑰: '钥',
	s钦: '欽',
	t欽: '钦',
	s钧: '鈞',
	t鈞: '钧',
	s钨: '鎢',
	t鎢: '钨',
	s钩: '鉤',
	t鉤: '钩',
	s钪: '鈧',
	t鈧: '钪',
	s钫: '鈁',
	t鈁: '钫',
	s钬: '鈥',
	t鈥: '钬',
	s钭: '鈄',
	t鈄: '钭',
	s钮: '鈕',
	t鈕: '钮',
	s钯: '鈀',
	t鈀: '钯',
	s钰: '鈺',
	t鈺: '钰',
	s钱: '錢',
	t錢: '钱',
	s钲: '鉦',
	t鉦: '钲',
	s钳: '鉗',
	t鉗: '钳',
	s钴: '鈷',
	t鈷: '钴',
	s钵: '缽',
	t缽: '钵',
	s钶: '鈳',
	t鈳: '钶',
	s钷: '鉕',
	t鉕: '钷',
	s钸: '鈽',
	t鈽: '钸',
	s钹: '鈸',
	t鈸: '钹',
	s钺: '鉞',
	t鉞: '钺',
	s钻: '鑽',
	t鑽: '钻',
	s钼: '鉬',
	t鉬: '钼',
	s钽: '鉭',
	t鉭: '钽',
	s钾: '鉀',
	t鉀: '钾',
	s钿: '鈿',
	t鈿: '钿',
	s铀: '鈾',
	t鈾: '铀',
	s铁: '鐵',
	t鐵: '铁',
	s铂: '鉑',
	t鉑: '铂',
	s铃: '鈴',
	t鈴: '铃',
	s铄: '鑠',
	t鑠: '铄',
	s铅: '鉛',
	t鉛: '铅',
	s铆: '鉚',
	t鉚: '铆',
	s铈: '鈰',
	t鈰: '铈',
	s铉: '鉉',
	t鉉: '铉',
	s铊: '鉈',
	t鉈: '铊',
	s铋: '鉍',
	t鉍: '铋',
	s铍: '鈹',
	t鈹: '铍',
	s铎: '鐸',
	t鐸: '铎',
	s铏: '鉶',
	t鉶: '铏',
	s铐: '銬',
	t銬: '铐',
	s铑: '銠',
	t銠: '铑',
	s铒: '鉺',
	t鉺: '铒',
	s铕: '銪',
	t銪: '铕',
	s铗: '鋏',
	t鋏: '铗',
	s铘: '鋣',
	t鋣: '铘',
	s铙: '鐃',
	t鐃: '铙',
	s铚: '銍',
	t銍: '铚',
	s铛: '鐺',
	t鐺: '铛',
	s铜: '銅',
	t銅: '铜',
	s铝: '鋁',
	t鋁: '铝',
	s铞: '銱',
	t銱: '铞',
	s铟: '銦',
	t銦: '铟',
	s铠: '鎧',
	t鎧: '铠',
	s铡: '鍘',
	t鍘: '铡',
	s铢: '銖',
	t銖: '铢',
	s铣: '銑',
	t銑: '铣',
	s铤: '鋌',
	t鋌: '铤',
	s铥: '銩',
	t銩: '铥',
	s铦: '銛',
	t銛: '铦',
	s铧: '鏵',
	t鏵: '铧',
	s铨: '銓',
	t銓: '铨',
	s铪: '鉿',
	t鉿: '铪',
	s铫: '銚',
	t銚: '铫',
	s铬: '鉻',
	t鉻: '铬',
	s铭: '銘',
	t銘: '铭',
	s铮: '錚',
	t錚: '铮',
	s铯: '銫',
	t銫: '铯',
	s铰: '鉸',
	t鉸: '铰',
	s铱: '銥',
	t銥: '铱',
	s铲: '鏟',
	t鏟: '铲',
	s铳: '銃',
	t銃: '铳',
	s铴: '鐋',
	t鐋: '铴',
	s铵: '銨',
	t銨: '铵',
	s银: '銀',
	t銀: '银',
	s铷: '銣',
	t銣: '铷',
	s铸: '鑄',
	t鑄: '铸',
	s铹: '鐒',
	t鐒: '铹',
	s铺: '鋪',
	t鋪: '铺',
	s铻: '鋙',
	t鋙: '铻',
	s铼: '錸',
	t錸: '铼',
	s铽: '鋱',
	t鋱: '铽',
	s链: '鏈',
	t鏈: '链',
	s铿: '鏗',
	t鏗: '铿',
	s销: '銷',
	t銷: '销',
	s锁: '鎖',
	t鎖: '锁',
	s锂: '鋰',
	t鋰: '锂',
	s锃: '鋥',
	t鋥: '锃',
	s锄: '鋤',
	t鋤: '锄',
	s锅: '鍋',
	t鍋: '锅',
	s锆: '鋯',
	t鋯: '锆',
	s锇: '鋨',
	t鋨: '锇',
	s锈: '鏽',
	t鏽: '锈',
	s锉: '銼',
	t銼: '锉',
	s锊: '鋝',
	t鋝: '锊',
	s锋: '鋒',
	t鋒: '锋',
	s锌: '鋅',
	t鋅: '锌',
	s锍: '鋶',
	t鋶: '锍',
	s锎: '鐦',
	t鐦: '锎',
	s锏: '鐧',
	t鐧: '锏',
	s锐: '銳',
	t銳: '锐',
	s锑: '銻',
	t銻: '锑',
	s锒: '鋃',
	t鋃: '锒',
	s锓: '鋟',
	t鋟: '锓',
	s锔: '鋦',
	t鋦: '锔',
	s锕: '錒',
	t錒: '锕',
	s锖: '錆',
	t錆: '锖',
	s锗: '鍺',
	t鍺: '锗',
	s错: '錯',
	t錯: '错',
	s锚: '錨',
	t錨: '锚',
	s锜: '錡',
	t錡: '锜',
	s锞: '錁',
	t錁: '锞',
	s锟: '錕',
	t錕: '锟',
	s锠: '錩',
	t錩: '锠',
	s锡: '錫',
	t錫: '锡',
	s锢: '錮',
	t錮: '锢',
	s锣: '鑼',
	t鑼: '锣',
	s锤: '錘',
	t錘: '锤',
	s锥: '錐',
	t錐: '锥',
	s锦: '錦',
	t錦: '锦',
	s锨: '鍁',
	t鍁: '锨',
	s锩: '錈',
	t錈: '锩',
	s锫: '錇',
	t錇: '锫',
	s锬: '錟',
	t錟: '锬',
	s锭: '錠',
	t錠: '锭',
	s键: '鍵',
	t鍵: '键',
	s锯: '鋸',
	t鋸: '锯',
	s锰: '錳',
	t錳: '锰',
	s锱: '錙',
	t錙: '锱',
	s锲: '鍥',
	t鍥: '锲',
	s锳: '鍈',
	t鍈: '锳',
	s锴: '鍇',
	t鍇: '锴',
	s锵: '鏘',
	t鏘: '锵',
	s锶: '鍶',
	t鍶: '锶',
	s锷: '鍔',
	t鍔: '锷',
	s锸: '鍤',
	t鍤: '锸',
	s锹: '鍬',
	t鍬: '锹',
	s锺: '鍾',
	s锻: '鍛',
	t鍛: '锻',
	s锼: '鎪',
	t鎪: '锼',
	s锽: '鍠',
	t鍠: '锽',
	s锾: '鍰',
	t鍰: '锾',
	s锿: '鎄',
	t鎄: '锿',
	s镀: '鍍',
	t鍍: '镀',
	s镁: '鎂',
	t鎂: '镁',
	s镂: '鏤',
	t鏤: '镂',
	s镃: '鎡',
	t鎡: '镃',
	s镆: '鏌',
	t鏌: '镆',
	s镇: '鎮',
	t鎮: '镇',
	s镈: '鎛',
	t鎛: '镈',
	s镉: '鎘',
	t鎘: '镉',
	s镊: '鑷',
	t鑷: '镊',
	s镌: '鐫',
	t鐫: '镌',
	s镍: '鎳',
	t鎳: '镍',
	s镎: '鎿',
	t鎿: '镎',
	s镏: '鎦',
	t鎦: '镏',
	s镐: '鎬',
	t鎬: '镐',
	s镑: '鎊',
	t鎊: '镑',
	s镒: '鎰',
	t鎰: '镒',
	s镕: '鎔',
	t鎔: '镕',
	s镖: '鏢',
	t鏢: '镖',
	s镗: '鏜',
	t鏜: '镗',
	s镙: '鏍',
	t鏍: '镙',
	s镚: '鏰',
	t鏰: '镚',
	s镛: '鏞',
	t鏞: '镛',
	s镜: '鏡',
	t鏡: '镜',
	s镝: '鏑',
	t鏑: '镝',
	s镞: '鏃',
	t鏃: '镞',
	s镟: '鏇',
	t鏇: '镟',
	s镠: '鏐',
	t鏐: '镠',
	s镡: '鐔',
	t鐔: '镡',
	s镢: '钁',
	t钁: '镢',
	s镣: '鐐',
	t鐐: '镣',
	s镤: '鏷',
	t鏷: '镤',
	s镥: '鑥',
	t鑥: '镥',
	s镦: '鐓',
	t鐓: '镦',
	s镧: '鑭',
	t鑭: '镧',
	s镨: '鐠',
	t鐠: '镨',
	s镩: '鑹',
	t鑹: '镩',
	s镪: '鏹',
	t鏹: '镪',
	s镫: '鐙',
	t鐙: '镫',
	s镬: '鑊',
	t鑊: '镬',
	s镭: '鐳',
	t鐳: '镭',
	s镮: '鐶',
	t鐶: '镮',
	s镯: '鐲',
	t鐲: '镯',
	s镰: '鐮',
	t鐮: '镰',
	s镱: '鐿',
	t鐿: '镱',
	s镲: '鑔',
	t鑔: '镲',
	s镳: '鑣',
	t鑣: '镳',
	s镴: '鑞',
	t鑞: '镴',
	s镶: '鑲',
	t鑲: '镶',
	s长: '長',
	t長: '长',
	s门: '門',
	t門: '门',
	s闩: '閂',
	t閂: '闩',
	s闪: '閃',
	t閃: '闪',
	s闫: '閆',
	t閆: '闫',
	s闬: '閈',
	t閈: '闬',
	s闭: '閉',
	t閉: '闭',
	s问: '問',
	t問: '问',
	s闯: '闖',
	t闖: '闯',
	s闰: '閏',
	t閏: '闰',
	s闱: '闈',
	t闈: '闱',
	s闲: '閒',
	t閑: '闲',
	s闳: '閎',
	t閎: '闳',
	s间: '間',
	t間: '间',
	s闵: '閔',
	t閔: '闵',
	s闶: '閌',
	t閌: '闶',
	s闷: '悶',
	t悶: '闷',
	s闸: '閘',
	t閘: '闸',
	s闹: '鬨',
	t鬧: '闹',
	s闺: '閨',
	t閨: '闺',
	s闻: '聞',
	t聞: '闻',
	s闼: '闥',
	t闥: '闼',
	s闽: '閩',
	t閩: '闽',
	s闾: '閭',
	t閭: '闾',
	s闿: '闓',
	t闓: '闿',
	s阀: '閥',
	t閥: '阀',
	s阁: '閣',
	t閣: '阁',
	s阂: '閡',
	t閡: '阂',
	s阃: '閫',
	t閫: '阃',
	s阄: '鬮',
	t鬮: '阄',
	s阅: '閱',
	t閱: '阅',
	s阆: '閬',
	t閬: '阆',
	s阇: '闍',
	t闍: '阇',
	s阈: '閾',
	t閾: '阈',
	s阉: '閹',
	t閹: '阉',
	s阊: '閶',
	t閶: '阊',
	s阋: '鬩',
	t鬩: '阋',
	s阌: '閿',
	t閿: '阌',
	s阍: '閽',
	t閽: '阍',
	s阎: '閻',
	t閻: '阎',
	s阏: '閼',
	t閼: '阏',
	s阐: '闡',
	t闡: '阐',
	s阑: '闌',
	t闌: '阑',
	s阒: '闃',
	t闃: '阒',
	s阓: '闠',
	t闠: '阓',
	s阔: '闊',
	t闊: '阔',
	s阕: '闋',
	t闋: '阕',
	s阖: '闔',
	t闔: '阖',
	s阗: '闐',
	t闐: '阗',
	s阘: '闒',
	t闒: '阘',
	s阙: '闕',
	t闕: '阙',
	s阚: '闞',
	t闞: '阚',
	s阛: '闤',
	t闤: '阛',
	s队: '隊',
	t隊: '队',
	s阳: '陽',
	t陽: '阳',
	s阴: '陰',
	t陰: '阴',
	s阵: '陣',
	t陣: '阵',
	s阶: '階',
	t階: '阶',
	s际: '際',
	t際: '际',
	s陆: '陸',
	t陸: '陆',
	s陇: '隴',
	t隴: '陇',
	s陈: '陳',
	t陳: '陈',
	s陉: '陘',
	t陘: '陉',
	s陕: '陝',
	t陝: '陕',
	s陧: '隉',
	t隉: '陧',
	s陨: '隕',
	t隕: '陨',
	s险: '險',
	t險: '险',
	s随: '隨',
	t隨: '随',
	s隐: '隱',
	t隱: '隐',
	s隶: '隸',
	t隸: '隶',
	s隽: '雋',
	t雋: '隽',
	s难: '難',
	t難: '难',
	s雏: '雛',
	t雛: '雏',
	s雠: '讎',
	t讎: '雠',
	s雳: '靂',
	t靂: '雳',
	s雾: '霧',
	t霧: '雾',
	s霁: '霽',
	t霽: '霁',
	s霉: '黴',
	t黴: '霉',
	s霭: '靄',
	t靄: '霭',
	s靓: '靚',
	t靚: '靓',
	s静: '靜',
	t靜: '静',
	s靥: '靨',
	t靨: '靥',
	s鞑: '韃',
	t韃: '鞑',
	s鞒: '鞽',
	t鞽: '鞒',
	s鞯: '韉',
	t韉: '鞯',
	s鞴: '韝',
	t韝: '鞴',
	s韦: '韋',
	t韋: '韦',
	s韧: '韌',
	t韌: '韧',
	s韨: '韍',
	t韍: '韨',
	s韩: '韓',
	t韓: '韩',
	s韪: '韙',
	t韙: '韪',
	s韫: '韞',
	t韞: '韫',
	s韬: '韜',
	t韜: '韬',
	s韵: '韻',
	t韻: '韵',
	s页: '頁',
	t頁: '页',
	s顶: '頂',
	t頂: '顶',
	s顷: '頃',
	t頃: '顷',
	s顸: '頇',
	t頇: '顸',
	s项: '項',
	t項: '项',
	s顺: '順',
	t順: '顺',
	s须: '須',
	t須: '须',
	s顼: '頊',
	t頊: '顼',
	s顽: '頑',
	t頑: '顽',
	s顾: '顧',
	t顧: '顾',
	s顿: '頓',
	t頓: '顿',
	s颀: '頎',
	t頎: '颀',
	s颁: '頒',
	t頒: '颁',
	s颂: '頌',
	t頌: '颂',
	s颃: '頏',
	t頏: '颃',
	s预: '預',
	t預: '预',
	s颅: '顱',
	t顱: '颅',
	s领: '領',
	t領: '领',
	s颇: '頗',
	t頗: '颇',
	s颈: '頸',
	t頸: '颈',
	s颉: '頡',
	t頡: '颉',
	s颊: '頰',
	t頰: '颊',
	s颋: '頲',
	t頲: '颋',
	s颌: '頜',
	t頜: '颌',
	s颍: '潁',
	t潁: '颍',
	s颎: '熲',
	t熲: '颎',
	s颏: '頦',
	t頦: '颏',
	s颐: '頤',
	t頤: '颐',
	s频: '頻',
	t頻: '频',
	s颒: '頮',
	t頮: '颒',
	s颓: '頹',
	t頹: '颓',
	s颔: '頷',
	t頷: '颔',
	s颕: '頴',
	t頴: '颕',
	s颖: '穎',
	t穎: '颖',
	s颗: '顆',
	t顆: '颗',
	s题: '題',
	t題: '题',
	s颙: '顒',
	t顒: '颙',
	s颚: '顎',
	t顎: '颚',
	s颛: '顓',
	t顓: '颛',
	s颜: '顏',
	t顏: '颜',
	s额: '額',
	t額: '额',
	s颞: '顳',
	t顳: '颞',
	s颟: '顢',
	t顢: '颟',
	s颠: '顛',
	t顛: '颠',
	s颡: '顙',
	t顙: '颡',
	s颢: '顥',
	t顥: '颢',
	s颣: '纇',
	t纇: '颣',
	s颤: '顫',
	t顫: '颤',
	s颥: '顬',
	t顬: '颥',
	s颦: '顰',
	t顰: '颦',
	s颧: '顴',
	t顴: '颧',
	s风: '風',
	t風: '风',
	s飏: '颺',
	t颺: '飏',
	s飐: '颭',
	t颭: '飐',
	s飑: '颮',
	t颮: '飑',
	s飒: '颯',
	t颯: '飒',
	s飓: '颶',
	t颶: '飓',
	s飔: '颸',
	t颸: '飔',
	s飕: '颼',
	t颼: '飕',
	s飖: '颻',
	t颻: '飖',
	s飗: '飀',
	t飀: '飗',
	s飘: '飄',
	t飄: '飘',
	s飙: '飆',
	t飆: '飚',
	s飚: '飆',
	s飞: '飛',
	t飛: '飞',
	s飨: '饗',
	t饗: '飨',
	s餍: '饜',
	t饜: '餍',
	s饤: '飣',
	t飣: '饤',
	s饥: '饑',
	t饑: '饥',
	s饦: '飥',
	t飥: '饦',
	s饧: '餳',
	t餳: '饧',
	s饨: '飩',
	t飩: '饨',
	s饩: '餼',
	t餼: '饩',
	s饪: '飪',
	t飪: '饪',
	s饫: '飫',
	t飫: '饫',
	s饬: '飭',
	t飭: '饬',
	s饭: '飯',
	t飯: '饭',
	s饮: '飲',
	t飲: '饮',
	s饯: '餞',
	t餞: '饯',
	s饰: '飾',
	t飾: '饰',
	s饱: '飽',
	t飽: '饱',
	s饲: '飼',
	t飼: '饲',
	s饳: '飿',
	t飿: '饳',
	s饴: '飴',
	t飴: '饴',
	s饵: '餌',
	t餌: '饵',
	s饶: '饒',
	t饒: '饶',
	s饷: '餉',
	t餉: '饷',
	s饸: '餄',
	t餄: '饸',
	s饹: '餎',
	t餎: '饹',
	s饺: '餃',
	t餃: '饺',
	s饻: '餏',
	t餏: '饻',
	s饼: '餅',
	t餅: '饼',
	s饽: '餑',
	t餑: '饽',
	s饾: '餖',
	t餖: '饾',
	s饿: '餓',
	t餓: '饿',
	s馀: '餘',
	s馁: '餒',
	t餒: '馁',
	s馂: '餕',
	t餕: '馂',
	s馃: '餜',
	t餜: '馃',
	s馄: '餛',
	t餛: '馄',
	s馅: '餡',
	t餡: '馅',
	s馆: '館',
	t館: '馆',
	s馇: '餷',
	t餷: '馇',
	s馈: '饋',
	t饋: '馈',
	s馉: '餶',
	t餶: '馉',
	s馊: '餿',
	t餿: '馊',
	s馋: '饞',
	t饞: '馋',
	s馌: '饁',
	t饁: '馌',
	s馍: '饃',
	t饃: '馍',
	s馎: '餺',
	t餺: '馎',
	s馏: '餾',
	t餾: '馏',
	s馐: '饈',
	t饈: '馐',
	s馑: '饉',
	t饉: '馑',
	s馒: '饅',
	t饅: '馒',
	s馓: '饊',
	t饊: '馓',
	s馔: '饌',
	t饌: '馔',
	s馕: '饢',
	t饢: '馕',
	s马: '馬',
	t馬: '马',
	s驭: '馭',
	t馭: '驭',
	s驮: '馱',
	t馱: '驮',
	s驯: '馴',
	t馴: '驯',
	s驰: '馳',
	t馳: '驰',
	s驱: '驅',
	t驅: '驱',
	s驲: '馹',
	t馹: '驲',
	s驳: '駁',
	t駁: '驳',
	s驴: '驢',
	t驢: '驴',
	s驵: '駔',
	t駔: '驵',
	s驶: '駛',
	t駛: '驶',
	s驷: '駟',
	t駟: '驷',
	s驸: '駙',
	t駙: '驸',
	s驹: '駒',
	t駒: '驹',
	s驺: '騶',
	t騶: '驺',
	s驻: '駐',
	t駐: '驻',
	s驼: '駝',
	t駝: '驼',
	s驽: '駑',
	t駑: '驽',
	s驾: '駕',
	t駕: '驾',
	s驿: '驛',
	t驛: '驿',
	s骀: '駘',
	t駘: '骀',
	s骁: '驍',
	t驍: '骁',
	s骂: '罵',
	t罵: '骂',
	s骃: '駰',
	t駰: '骃',
	s骄: '驕',
	t驕: '骄',
	s骅: '驊',
	t驊: '骅',
	s骆: '駱',
	t駱: '骆',
	s骇: '駭',
	t駭: '骇',
	s骈: '駢',
	t駢: '骈',
	s骉: '驫',
	t驫: '骉',
	s骊: '驪',
	t驪: '骊',
	s骋: '騁',
	t騁: '骋',
	s验: '驗',
	t驗: '验',
	s骍: '騂',
	t騂: '骍',
	s骎: '駸',
	t駸: '骎',
	s骏: '駿',
	t駿: '骏',
	s骐: '騏',
	t騏: '骐',
	s骑: '騎',
	t騎: '骑',
	s骒: '騍',
	t騍: '骒',
	s骓: '騅',
	t騅: '骓',
	s骔: '騌',
	t騌: '骔',
	s骕: '驌',
	t驌: '骕',
	s骖: '驂',
	t驂: '骖',
	s骗: '騙',
	t騙: '骗',
	s骘: '騭',
	t騭: '骘',
	s骙: '騤',
	t騤: '骙',
	s骚: '騷',
	t騷: '骚',
	s骛: '騖',
	t騖: '骛',
	s骜: '驁',
	t驁: '骜',
	s骝: '騮',
	t騮: '骝',
	s骞: '騫',
	t騫: '骞',
	s骟: '騸',
	t騸: '骟',
	s骠: '驃',
	t驃: '骠',
	s骡: '騾',
	t騾: '骡',
	s骢: '驄',
	t驄: '骢',
	s骣: '驏',
	t驏: '骣',
	s骤: '驟',
	t驟: '骤',
	s骥: '驥',
	t驥: '骥',
	s骦: '驦',
	t驦: '骦',
	s骧: '驤',
	t驤: '骧',
	s髅: '髏',
	t髏: '髅',
	s髋: '髖',
	t髖: '髋',
	s髌: '髕',
	t髕: '髌',
	s鬓: '鬢',
	t鬢: '鬓',
	s魇: '魘',
	t魘: '魇',
	s魉: '魎',
	t魎: '魉',
	s鱼: '魚',
	t魚: '鱼',
	s鱽: '魛',
	t魛: '鱽',
	s鱾: '魢',
	t魢: '鱾',
	s鱿: '魷',
	t魷: '鱿',
	s鲀: '魨',
	t魨: '鲀',
	s鲁: '魯',
	t魯: '鲁',
	s鲂: '魴',
	t魴: '鲂',
	s鲄: '魺',
	t魺: '鲄',
	s鲅: '鮁',
	t鮁: '鲅',
	s鲆: '鮃',
	t鮃: '鲆',
	s鲇: '鯰',
	t鯰: '鲶',
	s鲈: '鱸',
	t鱸: '鲈',
	s鲉: '鮋',
	t鮋: '鲉',
	s鲊: '鮓',
	t鮓: '鲊',
	s鲋: '鮒',
	t鮒: '鲋',
	s鲌: '鮊',
	t鮊: '鲌',
	s鲍: '鮑',
	t鮑: '鲍',
	s鲎: '鱟',
	t鱟: '鲎',
	s鲏: '鮍',
	t鮍: '鲏',
	s鲐: '鮐',
	t鮐: '鲐',
	s鲑: '鮭',
	t鮭: '鲑',
	s鲒: '鮚',
	t鮚: '鲒',
	s鲓: '鮳',
	t鮳: '鲓',
	s鲔: '鮪',
	t鮪: '鲔',
	s鲕: '鮞',
	t鮞: '鲕',
	s鲖: '鮦',
	t鮦: '鲖',
	s鲗: '鰂',
	t鰂: '鲗',
	s鲘: '鮜',
	t鮜: '鲘',
	s鲙: '鱠',
	t鱠: '鲙',
	s鲚: '鱭',
	t鱭: '鲚',
	s鲛: '鮫',
	t鮫: '鲛',
	s鲜: '鮮',
	t鮮: '鲜',
	s鲝: '鮺',
	t鮺: '鲝',
	s鲞: '鯗',
	t鯗: '鲞',
	s鲟: '鱘',
	t鱘: '鲟',
	s鲠: '鯁',
	t鯁: '鲠',
	s鲡: '鱺',
	t鱺: '鲡',
	s鲢: '鰱',
	t鰱: '鲢',
	s鲣: '鰹',
	t鰹: '鲣',
	s鲤: '鯉',
	t鯉: '鲤',
	s鲥: '鰣',
	t鰣: '鲥',
	s鲦: '鰷',
	t鰷: '鲦',
	s鲧: '鯀',
	t鯀: '鲧',
	s鲨: '鯊',
	t鯊: '鲨',
	s鲩: '鯇',
	t鯇: '鲩',
	s鲪: '鮶',
	t鮶: '鲪',
	s鲫: '鯽',
	t鯽: '鲫',
	s鲬: '鯒',
	t鯒: '鲬',
	s鲭: '鯖',
	t鯖: '鲭',
	s鲮: '鯪',
	t鯪: '鲮',
	s鲯: '鯕',
	t鯕: '鲯',
	s鲰: '鯫',
	t鯫: '鲰',
	s鲱: '鯡',
	t鯡: '鲱',
	s鲲: '鯤',
	t鯤: '鲲',
	s鲳: '鯧',
	t鯧: '鲳',
	s鲴: '鯝',
	t鯝: '鲴',
	s鲵: '鯢',
	t鯢: '鲵',
	s鲶: '鯰',
	s鲷: '鯛',
	t鯛: '鲷',
	s鲸: '鯨',
	t鯨: '鲸',
	s鲹: '鯵',
	t鯵: '鲹',
	s鲺: '鯴',
	t鯴: '鲺',
	s鲻: '鯔',
	t鯔: '鲻',
	s鲼: '鱝',
	t鱝: '鲼',
	s鲽: '鰈',
	t鰈: '鲽',
	s鲾: '鰏',
	t鰏: '鲾',
	s鲿: '鱨',
	t鱨: '鲿',
	s鳀: '鯷',
	t鯷: '鳀',
	s鳁: '鰮',
	t鰮: '鳁',
	s鳂: '鰃',
	t鰃: '鳂',
	s鳃: '鰓',
	t鰓: '鳃',
	s鳄: '鱷',
	t鱷: '鳄',
	s鳅: '鰍',
	t鰍: '鳅',
	s鳆: '鰒',
	t鰒: '鳆',
	s鳇: '鰉',
	t鰉: '鳇',
	s鳈: '鰁',
	t鰁: '鳈',
	s鳉: '鱂',
	t鱂: '鳉',
	s鳊: '鯿',
	t鯿: '鳊',
	s鳋: '鰠',
	t鰠: '鳋',
	s鳌: '鼇',
	t鼇: '鳌',
	s鳍: '鰭',
	t鰭: '鳍',
	s鳎: '鰨',
	t鰨: '鳎',
	s鳏: '鰥',
	t鰥: '鳏',
	s鳐: '鰩',
	t鰩: '鳐',
	s鳑: '鰟',
	t鰟: '鳑',
	s鳒: '鰜',
	t鰜: '鳒',
	s鳓: '鰳',
	t鰳: '鳓',
	s鳔: '鰾',
	t鰾: '鳔',
	s鳕: '鱈',
	t鱈: '鳕',
	s鳖: '鱉',
	t鱉: '鳖',
	s鳗: '鰻',
	t鰻: '鳗',
	s鳘: '鰵',
	t鰵: '鳘',
	s鳙: '鱅',
	t鱅: '鳙',
	s鳛: '鰼',
	t鰼: '鳛',
	s鳜: '鱖',
	t鱖: '鳜',
	s鳝: '鱔',
	t鱔: '鳝',
	s鳞: '鱗',
	t鱗: '鳞',
	s鳟: '鱒',
	t鱒: '鳟',
	s鳠: '鱯',
	t鱯: '鳠',
	s鳡: '鱤',
	t鱤: '鳡',
	s鳢: '鱧',
	t鱧: '鳢',
	s鳣: '鱣',
	t鱣: '鳣',
	s鸟: '鳥',
	t鳥: '鸟',
	s鸠: '鳩',
	t鳩: '鸠',
	s鸡: '雞',
	t雞: '鸡',
	s鸢: '鳶',
	t鳶: '鸢',
	s鸣: '鳴',
	t鳴: '鸣',
	s鸤: '鳲',
	t鳲: '鸤',
	s鸥: '鷗',
	t鷗: '鸥',
	s鸦: '鴉',
	t鴉: '鸦',
	s鸧: '鶬',
	t鶬: '鸧',
	s鸨: '鴇',
	t鴇: '鸨',
	s鸩: '鴆',
	t鴆: '鸩',
	s鸪: '鴣',
	t鴣: '鸪',
	s鸫: '鶇',
	t鶇: '鸫',
	s鸬: '鸕',
	t鸕: '鸬',
	s鸭: '鴨',
	t鴨: '鸭',
	s鸮: '鴞',
	t鴞: '鸮',
	s鸯: '鴦',
	t鴦: '鸯',
	s鸰: '鴒',
	t鴒: '鸰',
	s鸱: '鴟',
	t鴟: '鸱',
	s鸲: '鴝',
	t鴝: '鸲',
	s鸳: '鴛',
	t鴛: '鸳',
	s鸴: '鴬',
	t鴬: '鸴',
	s鸵: '鴕',
	t鴕: '鸵',
	s鸶: '鷥',
	t鷥: '鸶',
	s鸷: '鷙',
	t鷙: '鸷',
	s鸸: '鴯',
	t鴯: '鸸',
	s鸹: '鴰',
	t鴰: '鸹',
	s鸺: '鵂',
	t鵂: '鸺',
	s鸻: '鴴',
	t鴴: '鸻',
	s鸼: '鵃',
	t鵃: '鸼',
	s鸽: '鴿',
	t鴿: '鸽',
	s鸾: '鸞',
	t鸞: '鸾',
	s鸿: '鴻',
	t鴻: '鸿',
	s鹀: '鵐',
	t鵐: '鹀',
	s鹁: '鵓',
	t鵓: '鹁',
	s鹂: '鸝',
	t鸝: '鹂',
	s鹃: '鵑',
	t鵑: '鹃',
	s鹄: '鵠',
	t鵠: '鹄',
	s鹅: '鵝',
	t鵝: '鹅',
	s鹆: '鵒',
	t鵒: '鹆',
	s鹇: '鷳',
	t鷳: '鹇',
	s鹈: '鵜',
	t鵜: '鹈',
	s鹉: '鵡',
	t鵡: '鹉',
	s鹊: '鵲',
	t鵲: '鹊',
	s鹋: '鶓',
	t鶓: '鹋',
	s鹌: '鵪',
	t鵪: '鹌',
	s鹍: '鶤',
	t鶤: '鹍',
	s鹎: '鵯',
	t鵯: '鹎',
	s鹏: '鵬',
	t鵬: '鹏',
	s鹐: '鵮',
	t鵮: '鹐',
	s鹑: '鶉',
	t鶉: '鹑',
	s鹒: '鶊',
	t鶊: '鹒',
	s鹓: '鵷',
	t鵷: '鹓',
	s鹔: '鷫',
	t鷫: '鹔',
	s鹕: '鶘',
	t鶘: '鹕',
	s鹖: '鶡',
	t鶡: '鹖',
	s鹗: '鶚',
	t鶚: '鹗',
	s鹘: '鶻',
	t鶻: '鹘',
	s鹚: '鶿',
	t鶿: '鹚',
	s鹛: '鶥',
	t鶥: '鹛',
	s鹜: '鶩',
	t鶩: '鹜',
	s鹝: '鷊',
	t鷊: '鹝',
	s鹞: '鷂',
	t鷂: '鹞',
	s鹟: '鶲',
	t鶲: '鹟',
	s鹠: '鶹',
	t鶹: '鹠',
	s鹡: '鶺',
	t鶺: '鹡',
	s鹢: '鷁',
	t鷁: '鹢',
	s鹣: '鶼',
	t鶼: '鹣',
	s鹤: '鶴',
	t鶴: '鹤',
	s鹥: '鷖',
	t鷖: '鹥',
	s鹦: '鸚',
	t鸚: '鹦',
	s鹧: '鷓',
	t鷓: '鹧',
	s鹨: '鷚',
	t鷚: '鹨',
	s鹩: '鷯',
	t鷯: '鹩',
	s鹪: '鷦',
	t鷦: '鹪',
	s鹫: '鷲',
	t鷲: '鹫',
	s鹬: '鷸',
	t鷸: '鹬',
	s鹭: '鷺',
	t鷺: '鹭',
	s鹯: '鸇',
	t鸇: '鹯',
	s鹰: '鷹',
	t鷹: '鹰',
	s鹱: '鸌',
	t鸌: '鹱',
	s鹲: '鸏',
	t鸏: '鹲',
	s鹳: '鸛',
	t鸛: '鹳',
	s鹴: '鸘',
	t鸘: '鹴',
	s鹾: '鹺',
	t鹺: '鹾',
	s麦: '麥',
	t麥: '麦',
	s麸: '麩',
	t麩: '麸',
	s黄: '黃',
	t黃: '黄',
	s黉: '黌',
	t黌: '黉',
	s黡: '黶',
	t黶: '黡',
	s黩: '黷',
	t黷: '黩',
	s黪: '黲',
	t黲: '黪',
	s黾: '黽',
	t黽: '黾',
	s鼋: '黿',
	t黿: '鼋',
	s鼌: '鼂',
	t鼂: '鼌',
	s鼍: '鼉',
	t鼉: '鼍',
	s鼗: '鞀',
	t鞀: '鼗',
	s鼹: '鼴',
	t鼴: '鼹',
	s齄: '齇',
	t齇: '齄',
	s齐: '齊',
	t齊: '齐',
	s齑: '齏',
	t齏: '齑',
	s齿: '齒',
	t齒: '齿',
	s龀: '齔',
	t齔: '龀',
	s龁: '齕',
	t齕: '龁',
	s龂: '齗',
	t齗: '龂',
	s龃: '齟',
	t齟: '龃',
	s龄: '齡',
	t齡: '龄',
	s龅: '齙',
	t齙: '龅',
	s龆: '齠',
	t齠: '龆',
	s龇: '齜',
	t齜: '龇',
	s龈: '齦',
	t齦: '龈',
	s龉: '齬',
	t齬: '龉',
	s龊: '齪',
	t齪: '龊',
	s龋: '齲',
	t齲: '龋',
	s龌: '齷',
	t齷: '龌',
	s龙: '龍',
	t龍: '龙',
	s龚: '龔',
	t龔: '龚',
	s龛: '龕',
	t龕: '龛',
	s龟: '龜',
	t龜: '龟',
	s志: '誌',
	t誌: '志',
	s制: '製',
	t製: '制',
	s咨: '谘',
	t谘: '咨',
	s只: '隻',
	t隻: '只',
	t裡: '里',
	s系: '係',
	t係: '系',
	s范: '範',
	t範: '范',
	s松: '鬆',
	t鬆: '松',
	t冇: '没',
	s尝: '嘗',
	t嚐: '尝',
	t嘗: '尝',
	t鬨: '闹',
	s面: '麵',
	t麵: '面',
	s准: '準',
	t準: '准',
	t鐘: '钟',
	t彆: '别',
	t閒: '闲',
	t乾: '干',
	t儘: '尽',
	t臟: '脏',
	s拼: '拚',
	t拚: '拼',
};

/**
 * 翻譯
 * @param {string} text
 * @param {string} prefix
 * @returns {string}
 */
const t = (text, prefix) => {
	let result = '';
	for (let i = 0; i < text.length; i++) {
		const t = text[i];
		const st = stObj[`${prefix}${t}`] || t;
		result += st;
	}
	return result
};

// 繁轉簡
const toSimple = text => {
	return t(text, 't')
};

// 簡轉繁
const toTraditional = text => {
	return t(text, 's')
};

// 檢測中文字是否相等
const checkSameChinese = (text1, text2) => {
	if (text1.length !== text2.length) {
		return false
	}
	let same = true;
	for (let i = 0; i < text1.length; i++) {
		const t1 = text1[i];
		const t2 = text2[i];
		const stt = stObj[`t${t1}`];
		if (stt != null) {
			if (!(stt === t2 || t1 === t2)) {
				same = false;
				break
			}
		} else {
			if (t1 !== t2) {
				same = false;
				break
			}
		}
	}
	return same
};

// 檢測文字(參數1)是否包含關鍵字(參數2)
const checkIncludeText = (text, keyword) => {
	return toSimple(text).includes(toSimple(keyword))
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var moment$1 = {exports: {}};

(function (module, exports) {
(function (global, factory) {
	    module.exports = factory() ;
	}(commonjsGlobal, (function () {
	    var hookCallback;

	    function hooks() {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback(callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return (
	            input instanceof Array ||
	            Object.prototype.toString.call(input) === '[object Array]'
	        );
	    }

	    function isObject(input) {
	        // IE8 will treat undefined and null as object if it wasn't for
	        // input != null
	        return (
	            input != null &&
	            Object.prototype.toString.call(input) === '[object Object]'
	        );
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function isObjectEmpty(obj) {
	        if (Object.getOwnPropertyNames) {
	            return Object.getOwnPropertyNames(obj).length === 0;
	        } else {
	            var k;
	            for (k in obj) {
	                if (hasOwnProp(obj, k)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }

	    function isUndefined(input) {
	        return input === void 0;
	    }

	    function isNumber(input) {
	        return (
	            typeof input === 'number' ||
	            Object.prototype.toString.call(input) === '[object Number]'
	        );
	    }

	    function isDate(input) {
	        return (
	            input instanceof Date ||
	            Object.prototype.toString.call(input) === '[object Date]'
	        );
	    }

	    function map(arr, fn) {
	        var res = [],
	            i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function createUTC(input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty: false,
	            unusedTokens: [],
	            unusedInput: [],
	            overflow: -2,
	            charsLeftOver: 0,
	            nullInput: false,
	            invalidEra: null,
	            invalidMonth: null,
	            invalidFormat: false,
	            userInvalidated: false,
	            iso: false,
	            parsedDateParts: [],
	            era: null,
	            meridiem: null,
	            rfc2822: false,
	            weekdayMismatch: false,
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    var some;
	    if (Array.prototype.some) {
	        some = Array.prototype.some;
	    } else {
	        some = function (fun) {
	            var t = Object(this),
	                len = t.length >>> 0,
	                i;

	            for (i = 0; i < len; i++) {
	                if (i in t && fun.call(this, t[i], i, t)) {
	                    return true;
	                }
	            }

	            return false;
	        };
	    }

	    function isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m),
	                parsedParts = some.call(flags.parsedDateParts, function (i) {
	                    return i != null;
	                }),
	                isNowValid =
	                    !isNaN(m._d.getTime()) &&
	                    flags.overflow < 0 &&
	                    !flags.empty &&
	                    !flags.invalidEra &&
	                    !flags.invalidMonth &&
	                    !flags.invalidWeekday &&
	                    !flags.weekdayMismatch &&
	                    !flags.nullInput &&
	                    !flags.invalidFormat &&
	                    !flags.userInvalidated &&
	                    (!flags.meridiem || (flags.meridiem && parsedParts));

	            if (m._strict) {
	                isNowValid =
	                    isNowValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }

	            if (Object.isFrozen == null || !Object.isFrozen(m)) {
	                m._isValid = isNowValid;
	            } else {
	                return isNowValid;
	            }
	        }
	        return m._isValid;
	    }

	    function createInvalid(flags) {
	        var m = createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        } else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = (hooks.momentProperties = []),
	        updateInProgress = false;

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i = 0; i < momentProperties.length; i++) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        if (!this.isValid()) {
	            this._d = new Date(NaN);
	        }
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment(obj) {
	        return (
	            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
	        );
	    }

	    function warn(msg) {
	        if (
	            hooks.suppressDeprecationWarnings === false &&
	            typeof console !== 'undefined' &&
	            console.warn
	        ) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (hooks.deprecationHandler != null) {
	                hooks.deprecationHandler(null, msg);
	            }
	            if (firstTime) {
	                var args = [],
	                    arg,
	                    i,
	                    key;
	                for (i = 0; i < arguments.length; i++) {
	                    arg = '';
	                    if (typeof arguments[i] === 'object') {
	                        arg += '\n[' + i + '] ';
	                        for (key in arguments[0]) {
	                            if (hasOwnProp(arguments[0], key)) {
	                                arg += key + ': ' + arguments[0][key] + ', ';
	                            }
	                        }
	                        arg = arg.slice(0, -2); // Remove trailing comma and space
	                    } else {
	                        arg = arguments[i];
	                    }
	                    args.push(arg);
	                }
	                warn(
	                    msg +
	                        '\nArguments: ' +
	                        Array.prototype.slice.call(args).join('') +
	                        '\n' +
	                        new Error().stack
	                );
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(name, msg);
	        }
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    hooks.suppressDeprecationWarnings = false;
	    hooks.deprecationHandler = null;

	    function isFunction(input) {
	        return (
	            (typeof Function !== 'undefined' && input instanceof Function) ||
	            Object.prototype.toString.call(input) === '[object Function]'
	        );
	    }

	    function set(config) {
	        var prop, i;
	        for (i in config) {
	            if (hasOwnProp(config, i)) {
	                prop = config[i];
	                if (isFunction(prop)) {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	        // TODO: Remove "ordinalParse" fallback in next major release.
	        this._dayOfMonthOrdinalParseLenient = new RegExp(
	            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	                '|' +
	                /\d{1,2}/.source
	        );
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig),
	            prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        for (prop in parentConfig) {
	            if (
	                hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])
	            ) {
	                // make sure changes to properties don't modify parent config
	                res[prop] = extend({}, res[prop]);
	            }
	        }
	        return res;
	    }

	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }

	    var keys;

	    if (Object.keys) {
	        keys = Object.keys;
	    } else {
	        keys = function (obj) {
	            var i,
	                res = [];
	            for (i in obj) {
	                if (hasOwnProp(obj, i)) {
	                    res.push(i);
	                }
	            }
	            return res;
	        };
	    }

	    var defaultCalendar = {
	        sameDay: '[Today at] LT',
	        nextDay: '[Tomorrow at] LT',
	        nextWeek: 'dddd [at] LT',
	        lastDay: '[Yesterday at] LT',
	        lastWeek: '[Last] dddd [at] LT',
	        sameElse: 'L',
	    };

	    function calendar(key, mom, now) {
	        var output = this._calendar[key] || this._calendar['sameElse'];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (
	            (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
	            absNumber
	        );
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
	        formatFunctions = {},
	        formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken(token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(
	                    func.apply(this, arguments),
	                    token
	                );
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens),
	            i,
	            length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '',
	                i;
	            for (i = 0; i < length; i++) {
	                output += isFunction(array[i])
	                    ? array[i].call(mom, format)
	                    : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] =
	            formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(
	                localFormattingTokens,
	                replaceLongDateFormatTokens
	            );
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var defaultLongDateFormat = {
	        LTS: 'h:mm:ss A',
	        LT: 'h:mm A',
	        L: 'MM/DD/YYYY',
	        LL: 'MMMM D, YYYY',
	        LLL: 'MMMM D, YYYY h:mm A',
	        LLLL: 'dddd, MMMM D, YYYY h:mm A',
	    };

	    function longDateFormat(key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper
	            .match(formattingTokens)
	            .map(function (tok) {
	                if (
	                    tok === 'MMMM' ||
	                    tok === 'MM' ||
	                    tok === 'DD' ||
	                    tok === 'dddd'
	                ) {
	                    return tok.slice(1);
	                }
	                return tok;
	            })
	            .join('');

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate() {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d',
	        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	    function ordinal(number) {
	        return this._ordinal.replace('%d', number);
	    }

	    var defaultRelativeTime = {
	        future: 'in %s',
	        past: '%s ago',
	        s: 'a few seconds',
	        ss: '%d seconds',
	        m: 'a minute',
	        mm: '%d minutes',
	        h: 'an hour',
	        hh: '%d hours',
	        d: 'a day',
	        dd: '%d days',
	        w: 'a week',
	        ww: '%d weeks',
	        M: 'a month',
	        MM: '%d months',
	        y: 'a year',
	        yy: '%d years',
	    };

	    function relativeTime(number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return isFunction(output)
	            ? output(number, withoutSuffix, string, isFuture)
	            : output.replace(/%d/i, number);
	    }

	    function pastFuture(diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var aliases = {};

	    function addUnitAlias(unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string'
	            ? aliases[units] || aliases[units.toLowerCase()]
	            : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    var priorities = {};

	    function addUnitPriority(unit, priority) {
	        priorities[unit] = priority;
	    }

	    function getPrioritizedUnits(unitsObj) {
	        var units = [],
	            u;
	        for (u in unitsObj) {
	            if (hasOwnProp(unitsObj, u)) {
	                units.push({ unit: u, priority: priorities[u] });
	            }
	        }
	        units.sort(function (a, b) {
	            return a.priority - b.priority;
	        });
	        return units;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    function absFloor(number) {
	        if (number < 0) {
	            // -0 -> 0
	            return Math.ceil(number) || 0;
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    function makeGetSet(unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                set$1(this, unit, value);
	                hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get(this, unit);
	            }
	        };
	    }

	    function get(mom, unit) {
	        return mom.isValid()
	            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
	            : NaN;
	    }

	    function set$1(mom, unit, value) {
	        if (mom.isValid() && !isNaN(value)) {
	            if (
	                unit === 'FullYear' &&
	                isLeapYear(mom.year()) &&
	                mom.month() === 1 &&
	                mom.date() === 29
	            ) {
	                value = toInt(value);
	                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
	                    value,
	                    mom.month(),
	                    daysInMonth(value, mom.month())
	                );
	            } else {
	                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	            }
	        }
	    }

	    // MOMENTS

	    function stringGet(units) {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units]();
	        }
	        return this;
	    }

	    function stringSet(units, value) {
	        if (typeof units === 'object') {
	            units = normalizeObjectUnits(units);
	            var prioritized = getPrioritizedUnits(units),
	                i;
	            for (i = 0; i < prioritized.length; i++) {
	                this[prioritized[i].unit](units[prioritized[i].unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    var match1 = /\d/, //       0 - 9
	        match2 = /\d\d/, //      00 - 99
	        match3 = /\d{3}/, //     000 - 999
	        match4 = /\d{4}/, //    0000 - 9999
	        match6 = /[+-]?\d{6}/, // -999999 - 999999
	        match1to2 = /\d\d?/, //       0 - 99
	        match3to4 = /\d\d\d\d?/, //     999 - 9999
	        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
	        match1to3 = /\d{1,3}/, //       0 - 999
	        match1to4 = /\d{1,4}/, //       0 - 9999
	        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
	        matchUnsigned = /\d+/, //       0 - inf
	        matchSigned = /[+-]?\d+/, //    -inf - inf
	        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
	        // any word (or two) characters or numbers including two/three word month in arabic.
	        // includes scottish gaelic two word and hyphenated months
	        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
	        regexes;

	    regexes = {};

	    function addRegexToken(token, regex, strictRegex) {
	        regexes[token] = isFunction(regex)
	            ? regex
	            : function (isStrict, localeData) {
	                  return isStrict && strictRegex ? strictRegex : regex;
	              };
	    }

	    function getParseRegexForToken(token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(
	            s
	                .replace('\\', '')
	                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
	                    matched,
	                    p1,
	                    p2,
	                    p3,
	                    p4
	                ) {
	                    return p1 || p2 || p3 || p4;
	                })
	        );
	    }

	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken(token, callback) {
	        var i,
	            func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (isNumber(callback)) {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken(token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,
	        WEEK = 7,
	        WEEKDAY = 8;

	    function mod(n, x) {
	        return ((n % x) + x) % x;
	    }

	    var indexOf;

	    if (Array.prototype.indexOf) {
	        indexOf = Array.prototype.indexOf;
	    } else {
	        indexOf = function (o) {
	            // I know
	            var i;
	            for (i = 0; i < this.length; ++i) {
	                if (this[i] === o) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	    }

	    function daysInMonth(year, month) {
	        if (isNaN(year) || isNaN(month)) {
	            return NaN;
	        }
	        var modMonth = mod(month, 12);
	        year += (month - modMonth) / 12;
	        return modMonth === 1
	            ? isLeapYear(year)
	                ? 29
	                : 28
	            : 31 - ((modMonth % 7) % 2);
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PRIORITY

	    addUnitPriority('month', 8);

	    // PARSING

	    addRegexToken('M', match1to2);
	    addRegexToken('MM', match1to2, match2);
	    addRegexToken('MMM', function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
	            '_'
	        ),
	        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
	            '_'
	        ),
	        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
	        defaultMonthsShortRegex = matchWord,
	        defaultMonthsRegex = matchWord;

	    function localeMonths(m, format) {
	        if (!m) {
	            return isArray(this._months)
	                ? this._months
	                : this._months['standalone'];
	        }
	        return isArray(this._months)
	            ? this._months[m.month()]
	            : this._months[
	                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
	                      ? 'format'
	                      : 'standalone'
	              ][m.month()];
	    }

	    function localeMonthsShort(m, format) {
	        if (!m) {
	            return isArray(this._monthsShort)
	                ? this._monthsShort
	                : this._monthsShort['standalone'];
	        }
	        return isArray(this._monthsShort)
	            ? this._monthsShort[m.month()]
	            : this._monthsShort[
	                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
	              ][m.month()];
	    }

	    function handleStrictParse(monthName, format, strict) {
	        var i,
	            ii,
	            mom,
	            llc = monthName.toLocaleLowerCase();
	        if (!this._monthsParse) {
	            // this is not used
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	            for (i = 0; i < 12; ++i) {
	                mom = createUTC([2000, i]);
	                this._shortMonthsParse[i] = this.monthsShort(
	                    mom,
	                    ''
	                ).toLocaleLowerCase();
	                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeMonthsParse(monthName, format, strict) {
	        var i, mom, regex;

	        if (this._monthsParseExact) {
	            return handleStrictParse.call(this, monthName, format, strict);
	        }

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        // TODO: add sorting
	        // Sorting makes sure if one month (or abbr) is a prefix of another
	        // see sorting in computeMonthsParse
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp(
	                    '^' + this.months(mom, '').replace('.', '') + '$',
	                    'i'
	                );
	                this._shortMonthsParse[i] = new RegExp(
	                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
	                    'i'
	                );
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex =
	                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (
	                strict &&
	                format === 'MMMM' &&
	                this._longMonthsParse[i].test(monthName)
	            ) {
	                return i;
	            } else if (
	                strict &&
	                format === 'MMM' &&
	                this._shortMonthsParse[i].test(monthName)
	            ) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth(mom, value) {
	        var dayOfMonth;

	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }

	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (!isNumber(value)) {
	                    return mom;
	                }
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth(value) {
	        if (value != null) {
	            setMonth(this, value);
	            hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get(this, 'Month');
	        }
	    }

	    function getDaysInMonth() {
	        return daysInMonth(this.year(), this.month());
	    }

	    function monthsShortRegex(isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsShortRegex')) {
	                this._monthsShortRegex = defaultMonthsShortRegex;
	            }
	            return this._monthsShortStrictRegex && isStrict
	                ? this._monthsShortStrictRegex
	                : this._monthsShortRegex;
	        }
	    }

	    function monthsRegex(isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                this._monthsRegex = defaultMonthsRegex;
	            }
	            return this._monthsStrictRegex && isStrict
	                ? this._monthsStrictRegex
	                : this._monthsRegex;
	        }
	    }

	    function computeMonthsParse() {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var shortPieces = [],
	            longPieces = [],
	            mixedPieces = [],
	            i,
	            mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	        }
	        for (i = 0; i < 24; i++) {
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp(
	            '^(' + longPieces.join('|') + ')',
	            'i'
	        );
	        this._monthsShortStrictRegex = new RegExp(
	            '^(' + shortPieces.join('|') + ')',
	            'i'
	        );
	    }

	    // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
	    });

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY', 4], 0, 'year');
	    addFormatToken(0, ['YYYYY', 5], 0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PRIORITIES

	    addUnitPriority('year', 1);

	    // PARSING

	    addRegexToken('Y', matchSigned);
	    addRegexToken('YY', match1to2, match2);
	    addRegexToken('YYYY', match1to4, match4);
	    addRegexToken('YYYYY', match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] =
	            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    // HOOKS

	    hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', true);

	    function getIsLeapYear() {
	        return isLeapYear(this.year());
	    }

	    function createDate(y, m, d, h, M, s, ms) {
	        // can't just apply() to create a date:
	        // https://stackoverflow.com/q/181348
	        var date;
	        // the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            date = new Date(y + 400, m, d, h, M, s, ms);
	            if (isFinite(date.getFullYear())) {
	                date.setFullYear(y);
	            }
	        } else {
	            date = new Date(y, m, d, h, M, s, ms);
	        }

	        return date;
	    }

	    function createUTCDate(y) {
	        var date, args;
	        // the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            args = Array.prototype.slice.call(arguments);
	            // preserve leap years using a full 400 year cycle, then reset
	            args[0] = y + 400;
	            date = new Date(Date.UTC.apply(null, args));
	            if (isFinite(date.getUTCFullYear())) {
	                date.setUTCFullYear(y);
	            }
	        } else {
	            date = new Date(Date.UTC.apply(null, arguments));
	        }

	        return date;
	    }

	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	        return -fwdlw + fwd - 1;
	    }

	    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear,
	            resDayOfYear;

	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }

	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear,
	        };
	    }

	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek,
	            resYear;

	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }

	        return {
	            week: resWeek,
	            year: resYear,
	        };
	    }

	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }

	    // FORMATTING

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PRIORITIES

	    addUnitPriority('week', 5);
	    addUnitPriority('isoWeek', 5);

	    // PARSING

	    addRegexToken('w', match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W', match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
	        input,
	        week,
	        config,
	        token
	    ) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // LOCALES

	    function localeWeek(mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow: 0, // Sunday is the first day of the week.
	        doy: 6, // The week that contains Jan 6th is the first week of the year.
	    };

	    function localeFirstDayOfWeek() {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear() {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek(input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek(input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    // FORMATTING

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PRIORITY
	    addUnitPriority('day', 11);
	    addUnitPriority('weekday', 11);
	    addUnitPriority('isoWeekday', 11);

	    // PARSING

	    addRegexToken('d', match1to2);
	    addRegexToken('e', match1to2);
	    addRegexToken('E', match1to2);
	    addRegexToken('dd', function (isStrict, locale) {
	        return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd', function (isStrict, locale) {
	        return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd', function (isStrict, locale) {
	        return locale.weekdaysRegex(isStrict);
	    });

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    function parseIsoWeekday(input, locale) {
	        if (typeof input === 'string') {
	            return locale.weekdaysParse(input) % 7 || 7;
	        }
	        return isNaN(input) ? null : input;
	    }

	    // LOCALES
	    function shiftWeekdays(ws, n) {
	        return ws.slice(n, 7).concat(ws.slice(0, n));
	    }

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
	            '_'
	        ),
	        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        defaultWeekdaysRegex = matchWord,
	        defaultWeekdaysShortRegex = matchWord,
	        defaultWeekdaysMinRegex = matchWord;

	    function localeWeekdays(m, format) {
	        var weekdays = isArray(this._weekdays)
	            ? this._weekdays
	            : this._weekdays[
	                  m && m !== true && this._weekdays.isFormat.test(format)
	                      ? 'format'
	                      : 'standalone'
	              ];
	        return m === true
	            ? shiftWeekdays(weekdays, this._week.dow)
	            : m
	            ? weekdays[m.day()]
	            : weekdays;
	    }

	    function localeWeekdaysShort(m) {
	        return m === true
	            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
	            : m
	            ? this._weekdaysShort[m.day()]
	            : this._weekdaysShort;
	    }

	    function localeWeekdaysMin(m) {
	        return m === true
	            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
	            : m
	            ? this._weekdaysMin[m.day()]
	            : this._weekdaysMin;
	    }

	    function handleStrictParse$1(weekdayName, format, strict) {
	        var i,
	            ii,
	            mom,
	            llc = weekdayName.toLocaleLowerCase();
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._minWeekdaysParse = [];

	            for (i = 0; i < 7; ++i) {
	                mom = createUTC([2000, 1]).day(i);
	                this._minWeekdaysParse[i] = this.weekdaysMin(
	                    mom,
	                    ''
	                ).toLocaleLowerCase();
	                this._shortWeekdaysParse[i] = this.weekdaysShort(
	                    mom,
	                    ''
	                ).toLocaleLowerCase();
	                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeWeekdaysParse(weekdayName, format, strict) {
	        var i, mom, regex;

	        if (this._weekdaysParseExact) {
	            return handleStrictParse$1.call(this, weekdayName, format, strict);
	        }

	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already

	            mom = createUTC([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp(
	                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
	                    'i'
	                );
	                this._shortWeekdaysParse[i] = new RegExp(
	                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
	                    'i'
	                );
	                this._minWeekdaysParse[i] = new RegExp(
	                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
	                    'i'
	                );
	            }
	            if (!this._weekdaysParse[i]) {
	                regex =
	                    '^' +
	                    this.weekdays(mom, '') +
	                    '|^' +
	                    this.weekdaysShort(mom, '') +
	                    '|^' +
	                    this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (
	                strict &&
	                format === 'dddd' &&
	                this._fullWeekdaysParse[i].test(weekdayName)
	            ) {
	                return i;
	            } else if (
	                strict &&
	                format === 'ddd' &&
	                this._shortWeekdaysParse[i].test(weekdayName)
	            ) {
	                return i;
	            } else if (
	                strict &&
	                format === 'dd' &&
	                this._minWeekdaysParse[i].test(weekdayName)
	            ) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek(input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek(input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek(input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }

	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.

	        if (input != null) {
	            var weekday = parseIsoWeekday(input, this.localeData());
	            return this.day(this.day() % 7 ? weekday : weekday - 7);
	        } else {
	            return this.day() || 7;
	        }
	    }

	    function weekdaysRegex(isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysStrictRegex;
	            } else {
	                return this._weekdaysRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                this._weekdaysRegex = defaultWeekdaysRegex;
	            }
	            return this._weekdaysStrictRegex && isStrict
	                ? this._weekdaysStrictRegex
	                : this._weekdaysRegex;
	        }
	    }

	    function weekdaysShortRegex(isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysShortStrictRegex;
	            } else {
	                return this._weekdaysShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	            }
	            return this._weekdaysShortStrictRegex && isStrict
	                ? this._weekdaysShortStrictRegex
	                : this._weekdaysShortRegex;
	        }
	    }

	    function weekdaysMinRegex(isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysMinStrictRegex;
	            } else {
	                return this._weekdaysMinRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	            }
	            return this._weekdaysMinStrictRegex && isStrict
	                ? this._weekdaysMinStrictRegex
	                : this._weekdaysMinRegex;
	        }
	    }

	    function computeWeekdaysParse() {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var minPieces = [],
	            shortPieces = [],
	            longPieces = [],
	            mixedPieces = [],
	            i,
	            mom,
	            minp,
	            shortp,
	            longp;
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, 1]).day(i);
	            minp = regexEscape(this.weekdaysMin(mom, ''));
	            shortp = regexEscape(this.weekdaysShort(mom, ''));
	            longp = regexEscape(this.weekdays(mom, ''));
	            minPieces.push(minp);
	            shortPieces.push(shortp);
	            longPieces.push(longp);
	            mixedPieces.push(minp);
	            mixedPieces.push(shortp);
	            mixedPieces.push(longp);
	        }
	        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	        // will match the longer piece.
	        minPieces.sort(cmpLenRev);
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);

	        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._weekdaysShortRegex = this._weekdaysRegex;
	        this._weekdaysMinRegex = this._weekdaysRegex;

	        this._weekdaysStrictRegex = new RegExp(
	            '^(' + longPieces.join('|') + ')',
	            'i'
	        );
	        this._weekdaysShortStrictRegex = new RegExp(
	            '^(' + shortPieces.join('|') + ')',
	            'i'
	        );
	        this._weekdaysMinStrictRegex = new RegExp(
	            '^(' + minPieces.join('|') + ')',
	            'i'
	        );
	    }

	    // FORMATTING

	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }

	    function kFormat() {
	        return this.hours() || 24;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);

	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('hmmss', 0, 0, function () {
	        return (
	            '' +
	            hFormat.apply(this) +
	            zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2)
	        );
	    });

	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('Hmmss', 0, 0, function () {
	        return (
	            '' +
	            this.hours() +
	            zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2)
	        );
	    });

	    function meridiem(token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(
	                this.hours(),
	                this.minutes(),
	                lowercase
	            );
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PRIORITY
	    addUnitPriority('hour', 13);

	    // PARSING

	    function matchMeridiem(isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a', matchMeridiem);
	    addRegexToken('A', matchMeridiem);
	    addRegexToken('H', match1to2);
	    addRegexToken('h', match1to2);
	    addRegexToken('k', match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	    addRegexToken('kk', match1to2, match2);

	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['k', 'kk'], function (input, array, config) {
	        var kInput = toInt(input);
	        array[HOUR] = kInput === 24 ? 0 : kInput;
	    });
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4,
	            pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4,
	            pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });

	    // LOCALES

	    function localeIsPM(input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return (input + '').toLowerCase().charAt(0) === 'p';
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
	        // Setting the hour should keep the time, because the user explicitly
	        // specified which hour they want. So trying to maintain the same hour (in
	        // a new timezone) makes sense. Adding/subtracting hours does not follow
	        // this rule.
	        getSetHour = makeGetSet('Hours', true);

	    function localeMeridiem(hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }

	    var baseConfig = {
	        calendar: defaultCalendar,
	        longDateFormat: defaultLongDateFormat,
	        invalidDate: defaultInvalidDate,
	        ordinal: defaultOrdinal,
	        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	        relativeTime: defaultRelativeTime,

	        months: defaultLocaleMonths,
	        monthsShort: defaultLocaleMonthsShort,

	        week: defaultLocaleWeek,

	        weekdays: defaultLocaleWeekdays,
	        weekdaysMin: defaultLocaleWeekdaysMin,
	        weekdaysShort: defaultLocaleWeekdaysShort,

	        meridiemParse: defaultLocaleMeridiemParse,
	    };

	    // internal storage for locale config files
	    var locales = {},
	        localeFamilies = {},
	        globalLocale;

	    function commonPrefix(arr1, arr2) {
	        var i,
	            minl = Math.min(arr1.length, arr2.length);
	        for (i = 0; i < minl; i += 1) {
	            if (arr1[i] !== arr2[i]) {
	                return i;
	            }
	        }
	        return minl;
	    }

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0,
	            j,
	            next,
	            locale,
	            split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (
	                    next &&
	                    next.length >= j &&
	                    commonPrefix(split, next) >= j - 1
	                ) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return globalLocale;
	    }

	    function loadLocale(name) {
	        var oldLocale = null,
	            aliasedRequire;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (
	            locales[name] === undefined &&
	            'object' !== 'undefined' &&
	            module &&
	            module.exports
	        ) {
	            try {
	                oldLocale = globalLocale._abbr;
	                aliasedRequire = commonjsRequire;
	                aliasedRequire('./locale/' + name);
	                getSetGlobalLocale(oldLocale);
	            } catch (e) {
	                // mark as not found to avoid repeating expensive file require call causing high CPU
	                // when trying to find en-US, en_US, en-us for every format call
	                locales[name] = null; // null means not found
	            }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function getSetGlobalLocale(key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = getLocale(key);
	            } else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            } else {
	                if (typeof console !== 'undefined' && console.warn) {
	                    //warn user if arguments are passed but the locale could not be set
	                    console.warn(
	                        'Locale ' + key + ' not found. Did you forget to load it?'
	                    );
	                }
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale(name, config) {
	        if (config !== null) {
	            var locale,
	                parentConfig = baseConfig;
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple(
	                    'defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale ' +
	                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
	                );
	                parentConfig = locales[name]._config;
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    parentConfig = locales[config.parentLocale]._config;
	                } else {
	                    locale = loadLocale(config.parentLocale);
	                    if (locale != null) {
	                        parentConfig = locale._config;
	                    } else {
	                        if (!localeFamilies[config.parentLocale]) {
	                            localeFamilies[config.parentLocale] = [];
	                        }
	                        localeFamilies[config.parentLocale].push({
	                            name: name,
	                            config: config,
	                        });
	                        return null;
	                    }
	                }
	            }
	            locales[name] = new Locale(mergeConfigs(parentConfig, config));

	            if (localeFamilies[name]) {
	                localeFamilies[name].forEach(function (x) {
	                    defineLocale(x.name, x.config);
	                });
	            }

	            // backwards compat for now: also set the locale
	            // make sure we set the locale AFTER all child locales have been
	            // created, so we won't end up with the child locale set.
	            getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale,
	                tmpLocale,
	                parentConfig = baseConfig;

	            if (locales[name] != null && locales[name].parentLocale != null) {
	                // Update existing child locale in-place to avoid memory-leaks
	                locales[name].set(mergeConfigs(locales[name]._config, config));
	            } else {
	                // MERGE
	                tmpLocale = loadLocale(name);
	                if (tmpLocale != null) {
	                    parentConfig = tmpLocale._config;
	                }
	                config = mergeConfigs(parentConfig, config);
	                if (tmpLocale == null) {
	                    // updateLocale is called for creating a new locale
	                    // Set abbr so it will have a name (getters return
	                    // undefined otherwise).
	                    config.abbr = name;
	                }
	                locale = new Locale(config);
	                locale.parentLocale = locales[name];
	                locales[name] = locale;
	            }

	            // backwards compat for now: also set the locale
	            getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                    if (name === getSetGlobalLocale()) {
	                        getSetGlobalLocale(name);
	                    }
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }

	    // returns locale data
	    function getLocale(key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    function listLocales() {
	        return keys(locales);
	    }

	    function checkOverflow(m) {
	        var overflow,
	            a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH] < 0 || a[MONTH] > 11
	                    ? MONTH
	                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
	                    ? DATE
	                    : a[HOUR] < 0 ||
	                      a[HOUR] > 24 ||
	                      (a[HOUR] === 24 &&
	                          (a[MINUTE] !== 0 ||
	                              a[SECOND] !== 0 ||
	                              a[MILLISECOND] !== 0))
	                    ? HOUR
	                    : a[MINUTE] < 0 || a[MINUTE] > 59
	                    ? MINUTE
	                    : a[SECOND] < 0 || a[SECOND] > 59
	                    ? SECOND
	                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
	                    ? MILLISECOND
	                    : -1;

	            if (
	                getParsingFlags(m)._overflowDayOfYear &&
	                (overflow < YEAR || overflow > DATE)
	            ) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
	        isoDates = [
	            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	            ['YYYY-DDD', /\d{4}-\d{3}/],
	            ['YYYY-MM', /\d{4}-\d\d/, false],
	            ['YYYYYYMMDD', /[+-]\d{10}/],
	            ['YYYYMMDD', /\d{8}/],
	            ['GGGG[W]WWE', /\d{4}W\d{3}/],
	            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	            ['YYYYDDD', /\d{7}/],
	            ['YYYYMM', /\d{6}/, false],
	            ['YYYY', /\d{4}/, false],
	        ],
	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	            ['HH:mm', /\d\d:\d\d/],
	            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	            ['HHmmss', /\d\d\d\d\d\d/],
	            ['HHmm', /\d\d\d\d/],
	            ['HH', /\d\d/],
	        ],
	        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
	        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
	        obsOffsets = {
	            UT: 0,
	            GMT: 0,
	            EDT: -4 * 60,
	            EST: -5 * 60,
	            CDT: -5 * 60,
	            CST: -6 * 60,
	            MDT: -6 * 60,
	            MST: -7 * 60,
	            PDT: -7 * 60,
	            PST: -8 * 60,
	        };

	    // date from iso format
	    function configFromISO(config) {
	        var i,
	            l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime,
	            dateFormat,
	            timeFormat,
	            tzFormat;

	        if (match) {
	            getParsingFlags(config).iso = true;

	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    function extractFromRFC2822Strings(
	        yearStr,
	        monthStr,
	        dayStr,
	        hourStr,
	        minuteStr,
	        secondStr
	    ) {
	        var result = [
	            untruncateYear(yearStr),
	            defaultLocaleMonthsShort.indexOf(monthStr),
	            parseInt(dayStr, 10),
	            parseInt(hourStr, 10),
	            parseInt(minuteStr, 10),
	        ];

	        if (secondStr) {
	            result.push(parseInt(secondStr, 10));
	        }

	        return result;
	    }

	    function untruncateYear(yearStr) {
	        var year = parseInt(yearStr, 10);
	        if (year <= 49) {
	            return 2000 + year;
	        } else if (year <= 999) {
	            return 1900 + year;
	        }
	        return year;
	    }

	    function preprocessRFC2822(s) {
	        // Remove comments and folding whitespace and replace multiple-spaces with a single space
	        return s
	            .replace(/\([^)]*\)|[\n\t]/g, ' ')
	            .replace(/(\s\s+)/g, ' ')
	            .replace(/^\s\s*/, '')
	            .replace(/\s\s*$/, '');
	    }

	    function checkWeekday(weekdayStr, parsedInput, config) {
	        if (weekdayStr) {
	            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
	            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	                weekdayActual = new Date(
	                    parsedInput[0],
	                    parsedInput[1],
	                    parsedInput[2]
	                ).getDay();
	            if (weekdayProvided !== weekdayActual) {
	                getParsingFlags(config).weekdayMismatch = true;
	                config._isValid = false;
	                return false;
	            }
	        }
	        return true;
	    }

	    function calculateOffset(obsOffset, militaryOffset, numOffset) {
	        if (obsOffset) {
	            return obsOffsets[obsOffset];
	        } else if (militaryOffset) {
	            // the only allowed military tz is Z
	            return 0;
	        } else {
	            var hm = parseInt(numOffset, 10),
	                m = hm % 100,
	                h = (hm - m) / 100;
	            return h * 60 + m;
	        }
	    }

	    // date and time from ref 2822 format
	    function configFromRFC2822(config) {
	        var match = rfc2822.exec(preprocessRFC2822(config._i)),
	            parsedArray;
	        if (match) {
	            parsedArray = extractFromRFC2822Strings(
	                match[4],
	                match[3],
	                match[2],
	                match[5],
	                match[6],
	                match[7]
	            );
	            if (!checkWeekday(match[1], parsedArray, config)) {
	                return;
	            }

	            config._a = parsedArray;
	            config._tzm = calculateOffset(match[8], match[9], match[10]);

	            config._d = createUTCDate.apply(null, config._a);
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	            getParsingFlags(config).rfc2822 = true;
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);
	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	        } else {
	            return;
	        }

	        configFromRFC2822(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	        } else {
	            return;
	        }

	        if (config._strict) {
	            config._isValid = false;
	        } else {
	            // Final attempt, use Input Fallback
	            hooks.createFromInputFallback(config);
	        }
	    }

	    hooks.createFromInputFallback = deprecate(
	        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
	            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
	            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(hooks.now());
	        if (config._useUTC) {
	            return [
	                nowValue.getUTCFullYear(),
	                nowValue.getUTCMonth(),
	                nowValue.getUTCDate(),
	            ];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray(config) {
	        var i,
	            date,
	            input = [],
	            currentDate,
	            expectedWeekday,
	            yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear != null) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (
	                config._dayOfYear > daysInYear(yearToUse) ||
	                config._dayOfYear === 0
	            ) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] =
	                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (
	            config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0
	        ) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(
	            null,
	            input
	        );
	        expectedWeekday = config._useUTC
	            ? config._d.getUTCDay()
	            : config._d.getDay();

	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }

	        // check for mismatching day of week
	        if (
	            config._w &&
	            typeof config._w.d !== 'undefined' &&
	            config._w.d !== expectedWeekday
	        ) {
	            getParsingFlags(config).weekdayMismatch = true;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(
	                w.GG,
	                config._a[YEAR],
	                weekOfYear(createLocal(), 1, 4).year
	            );
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            curWeek = weekOfYear(createLocal(), dow, doy);

	            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	            // Default to current week.
	            week = defaults(w.w, curWeek.week);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from beginning of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to beginning of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }

	    // constant that refers to the ISO standard
	    hooks.ISO_8601 = function () {};

	    // constant that refers to the RFC 2822 form
	    hooks.RFC_2822 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	        if (config._f === hooks.RFC_2822) {
	            configFromRFC2822(config);
	            return;
	        }
	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i,
	            parsedInput,
	            tokens,
	            token,
	            skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0,
	            era;

	        tokens =
	            expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
	                [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(
	                    string.indexOf(parsedInput) + parsedInput.length
	                );
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                } else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            } else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver =
	            stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (
	            config._a[HOUR] <= 12 &&
	            getParsingFlags(config).bigHour === true &&
	            config._a[HOUR] > 0
	        ) {
	            getParsingFlags(config).bigHour = undefined;
	        }

	        getParsingFlags(config).parsedDateParts = config._a.slice(0);
	        getParsingFlags(config).meridiem = config._meridiem;
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(
	            config._locale,
	            config._a[HOUR],
	            config._meridiem
	        );

	        // handle era
	        era = getParsingFlags(config).era;
	        if (era !== null) {
	            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
	        }

	        configFromArray(config);
	        checkOverflow(config);
	    }

	    function meridiemFixWrap(locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	            scoreToBeat,
	            i,
	            currentScore,
	            validFormatFound,
	            bestFormatIsValid = false;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            validFormatFound = false;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (isValid(tempConfig)) {
	                validFormatFound = true;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (!bestFormatIsValid) {
	                if (
	                    scoreToBeat == null ||
	                    currentScore < scoreToBeat ||
	                    validFormatFound
	                ) {
	                    scoreToBeat = currentScore;
	                    bestMoment = tempConfig;
	                    if (validFormatFound) {
	                        bestFormatIsValid = true;
	                    }
	                }
	            } else {
	                if (currentScore < scoreToBeat) {
	                    scoreToBeat = currentScore;
	                    bestMoment = tempConfig;
	                }
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i),
	            dayOrDate = i.day === undefined ? i.date : i.day;
	        config._a = map(
	            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
	            function (obj) {
	                return obj && parseInt(obj, 10);
	            }
	        );

	        configFromArray(config);
	    }

	    function createFromConfig(config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig(config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return createInvalid({ nullInput: true });
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isDate(input)) {
	            config._d = input;
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else {
	            configFromInput(config);
	        }

	        if (!isValid(config)) {
	            config._d = null;
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (isUndefined(input)) {
	            config._d = new Date(hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(input.valueOf());
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (isObject(input)) {
	            configFromObject(config);
	        } else if (isNumber(input)) {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC(input, format, locale, strict, isUTC) {
	        var c = {};

	        if (format === true || format === false) {
	            strict = format;
	            format = undefined;
	        }

	        if (locale === true || locale === false) {
	            strict = locale;
	            locale = undefined;
	        }

	        if (
	            (isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)
	        ) {
	            input = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function createLocal(input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	            function () {
	                var other = createLocal.apply(null, arguments);
	                if (this.isValid() && other.isValid()) {
	                    return other < this ? this : other;
	                } else {
	                    return createInvalid();
	                }
	            }
	        ),
	        prototypeMax = deprecate(
	            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	            function () {
	                var other = createLocal.apply(null, arguments);
	                if (this.isValid() && other.isValid()) {
	                    return other > this ? this : other;
	                } else {
	                    return createInvalid();
	                }
	            }
	        );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min() {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max() {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    var now = function () {
	        return Date.now ? Date.now() : +new Date();
	    };

	    var ordering = [
	        'year',
	        'quarter',
	        'month',
	        'week',
	        'day',
	        'hour',
	        'minute',
	        'second',
	        'millisecond',
	    ];

	    function isDurationValid(m) {
	        var key,
	            unitHasDecimal = false,
	            i;
	        for (key in m) {
	            if (
	                hasOwnProp(m, key) &&
	                !(
	                    indexOf.call(ordering, key) !== -1 &&
	                    (m[key] == null || !isNaN(m[key]))
	                )
	            ) {
	                return false;
	            }
	        }

	        for (i = 0; i < ordering.length; ++i) {
	            if (m[ordering[i]]) {
	                if (unitHasDecimal) {
	                    return false; // only allow non-integers for smallest unit
	                }
	                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                    unitHasDecimal = true;
	                }
	            }
	        }

	        return true;
	    }

	    function isValid$1() {
	        return this._isValid;
	    }

	    function createInvalid$1() {
	        return createDuration(NaN);
	    }

	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        this._isValid = isDurationValid(normalizedInput);

	        // representation for dateAddRemove
	        this._milliseconds =
	            +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days + weeks * 7;
	        // It is impossible to translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months + quarters * 3 + years * 12;

	        this._data = {};

	        this._locale = getLocale();

	        this._bubble();
	    }

	    function isDuration(obj) {
	        return obj instanceof Duration;
	    }

	    function absRound(number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if (
	                (dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
	            ) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    // FORMATTING

	    function offset(token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset(),
	                sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return (
	                sign +
	                zeroFill(~~(offset / 60), 2) +
	                separator +
	                zeroFill(~~offset % 60, 2)
	            );
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z', matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	        var matches = (string || '').match(matcher),
	            chunk,
	            parts,
	            minutes;

	        if (matches === null) {
	            return null;
	        }

	        chunk = matches[matches.length - 1] || [];
	        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff =
	                (isMoment(input) || isDate(input)
	                    ? input.valueOf()
	                    : createLocal(input).valueOf()) - res.valueOf();
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(res._d.valueOf() + diff);
	            hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return createLocal(input).local();
	        }
	    }

	    function getDateOffset(m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset());
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset(input, keepLocalTime, keepMinutes) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	                if (input === null) {
	                    return this;
	                }
	            } else if (Math.abs(input) < 16 && !keepMinutes) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    addSubtract(
	                        this,
	                        createDuration(input - offset, 'm'),
	                        1,
	                        false
	                    );
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone(input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC(keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal(keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset() {
	        if (this._tzm != null) {
	            this.utcOffset(this._tzm, false, true);
	        } else if (typeof this._i === 'string') {
	            var tZone = offsetFromString(matchOffset, this._i);
	            if (tZone != null) {
	                this.utcOffset(tZone);
	            } else {
	                this.utcOffset(0, true);
	            }
	        }
	        return this;
	    }

	    function hasAlignedHourOffset(input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime() {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted() {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }

	        var c = {},
	            other;

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	            this._isDSTShifted =
	                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal() {
	        return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset() {
	        return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc() {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }

	    // ASP.NET json date format regex
	    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        // and further modified to allow for strings containing both week and day
	        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	    function createDuration(input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months,
	            };
	        } else if (isNumber(input) || !isNaN(+input)) {
	            duration = {};
	            if (key) {
	                duration[key] = +input;
	            } else {
	                duration.milliseconds = +input;
	            }
	        } else if ((match = aspNetRegex.exec(input))) {
	            sign = match[1] === '-' ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
	            };
	        } else if ((match = isoRegex.exec(input))) {
	            sign = match[1] === '-' ? -1 : 1;
	            duration = {
	                y: parseIso(match[2], sign),
	                M: parseIso(match[3], sign),
	                w: parseIso(match[4], sign),
	                d: parseIso(match[5], sign),
	                h: parseIso(match[6], sign),
	                m: parseIso(match[7], sign),
	                s: parseIso(match[8], sign),
	            };
	        } else if (duration == null) {
	            // checks for null or undefined
	            duration = {};
	        } else if (
	            typeof duration === 'object' &&
	            ('from' in duration || 'to' in duration)
	        ) {
	            diffRes = momentsDifference(
	                createLocal(duration.from),
	                createLocal(duration.to)
	            );

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
	            ret._isValid = input._isValid;
	        }

	        return ret;
	    }

	    createDuration.fn = Duration.prototype;
	    createDuration.invalid = createInvalid$1;

	    function parseIso(inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {};

	        res.months =
	            other.month() - base.month() + (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +base.clone().add(res.months, 'M');

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return { milliseconds: 0, months: 0 };
	        }

	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(
	                    name,
	                    'moment().' +
	                        name +
	                        '(period, number) is deprecated. Please use moment().' +
	                        name +
	                        '(number, period). ' +
	                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
	                );
	                tmp = val;
	                val = period;
	                period = tmp;
	            }

	            dur = createDuration(val, period);
	            addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function addSubtract(mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);

	        if (!mom.isValid()) {
	            // No op
	            return;
	        }

	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (months) {
	            setMonth(mom, get(mom, 'Month') + months * isAdding);
	        }
	        if (days) {
	            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	        }
	        if (milliseconds) {
	            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	        }
	        if (updateOffset) {
	            hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add = createAdder(1, 'add'),
	        subtract = createAdder(-1, 'subtract');

	    function isString(input) {
	        return typeof input === 'string' || input instanceof String;
	    }

	    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
	    function isMomentInput(input) {
	        return (
	            isMoment(input) ||
	            isDate(input) ||
	            isString(input) ||
	            isNumber(input) ||
	            isNumberOrStringArray(input) ||
	            isMomentInputObject(input) ||
	            input === null ||
	            input === undefined
	        );
	    }

	    function isMomentInputObject(input) {
	        var objectTest = isObject(input) && !isObjectEmpty(input),
	            propertyTest = false,
	            properties = [
	                'years',
	                'year',
	                'y',
	                'months',
	                'month',
	                'M',
	                'days',
	                'day',
	                'd',
	                'dates',
	                'date',
	                'D',
	                'hours',
	                'hour',
	                'h',
	                'minutes',
	                'minute',
	                'm',
	                'seconds',
	                'second',
	                's',
	                'milliseconds',
	                'millisecond',
	                'ms',
	            ],
	            i,
	            property;

	        for (i = 0; i < properties.length; i += 1) {
	            property = properties[i];
	            propertyTest = propertyTest || hasOwnProp(input, property);
	        }

	        return objectTest && propertyTest;
	    }

	    function isNumberOrStringArray(input) {
	        var arrayTest = isArray(input),
	            dataTypeTest = false;
	        if (arrayTest) {
	            dataTypeTest =
	                input.filter(function (item) {
	                    return !isNumber(item) && isString(input);
	                }).length === 0;
	        }
	        return arrayTest && dataTypeTest;
	    }

	    function isCalendarSpec(input) {
	        var objectTest = isObject(input) && !isObjectEmpty(input),
	            propertyTest = false,
	            properties = [
	                'sameDay',
	                'nextDay',
	                'lastDay',
	                'nextWeek',
	                'lastWeek',
	                'sameElse',
	            ],
	            i,
	            property;

	        for (i = 0; i < properties.length; i += 1) {
	            property = properties[i];
	            propertyTest = propertyTest || hasOwnProp(input, property);
	        }

	        return objectTest && propertyTest;
	    }

	    function getCalendarFormat(myMoment, now) {
	        var diff = myMoment.diff(now, 'days', true);
	        return diff < -6
	            ? 'sameElse'
	            : diff < -1
	            ? 'lastWeek'
	            : diff < 0
	            ? 'lastDay'
	            : diff < 1
	            ? 'sameDay'
	            : diff < 2
	            ? 'nextDay'
	            : diff < 7
	            ? 'nextWeek'
	            : 'sameElse';
	    }

	    function calendar$1(time, formats) {
	        // Support for single parameter, formats only overload to the calendar function
	        if (arguments.length === 1) {
	            if (!arguments[0]) {
	                time = undefined;
	                formats = undefined;
	            } else if (isMomentInput(arguments[0])) {
	                time = arguments[0];
	                formats = undefined;
	            } else if (isCalendarSpec(arguments[0])) {
	                formats = arguments[0];
	                time = undefined;
	            }
	        }
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            format = hooks.calendarFormat(this, sod) || 'sameElse',
	            output =
	                formats &&
	                (isFunction(formats[format])
	                    ? formats[format].call(this, now)
	                    : formats[format]);

	        return this.format(
	            output || this.localeData().calendar(format, this, createLocal(now))
	        );
	    }

	    function clone() {
	        return new Moment(this);
	    }

	    function isAfter(input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() > localInput.valueOf();
	        } else {
	            return localInput.valueOf() < this.clone().startOf(units).valueOf();
	        }
	    }

	    function isBefore(input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() < localInput.valueOf();
	        } else {
	            return this.clone().endOf(units).valueOf() < localInput.valueOf();
	        }
	    }

	    function isBetween(from, to, units, inclusivity) {
	        var localFrom = isMoment(from) ? from : createLocal(from),
	            localTo = isMoment(to) ? to : createLocal(to);
	        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
	            return false;
	        }
	        inclusivity = inclusivity || '()';
	        return (
	            (inclusivity[0] === '('
	                ? this.isAfter(localFrom, units)
	                : !this.isBefore(localFrom, units)) &&
	            (inclusivity[1] === ')'
	                ? this.isBefore(localTo, units)
	                : !this.isAfter(localTo, units))
	        );
	    }

	    function isSame(input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() === localInput.valueOf();
	        } else {
	            inputMs = localInput.valueOf();
	            return (
	                this.clone().startOf(units).valueOf() <= inputMs &&
	                inputMs <= this.clone().endOf(units).valueOf()
	            );
	        }
	    }

	    function isSameOrAfter(input, units) {
	        return this.isSame(input, units) || this.isAfter(input, units);
	    }

	    function isSameOrBefore(input, units) {
	        return this.isSame(input, units) || this.isBefore(input, units);
	    }

	    function diff(input, units, asFloat) {
	        var that, zoneDelta, output;

	        if (!this.isValid()) {
	            return NaN;
	        }

	        that = cloneWithOffset(input, this);

	        if (!that.isValid()) {
	            return NaN;
	        }

	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	        units = normalizeUnits(units);

	        switch (units) {
	            case 'year':
	                output = monthDiff(this, that) / 12;
	                break;
	            case 'month':
	                output = monthDiff(this, that);
	                break;
	            case 'quarter':
	                output = monthDiff(this, that) / 3;
	                break;
	            case 'second':
	                output = (this - that) / 1e3;
	                break; // 1000
	            case 'minute':
	                output = (this - that) / 6e4;
	                break; // 1000 * 60
	            case 'hour':
	                output = (this - that) / 36e5;
	                break; // 1000 * 60 * 60
	            case 'day':
	                output = (this - that - zoneDelta) / 864e5;
	                break; // 1000 * 60 * 60 * 24, negate dst
	            case 'week':
	                output = (this - that - zoneDelta) / 6048e5;
	                break; // 1000 * 60 * 60 * 24 * 7, negate dst
	            default:
	                output = this - that;
	        }

	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff(a, b) {
	        if (a.date() < b.date()) {
	            // end-of-month calculations work correct when the start month has more
	            // days than the end month.
	            return -monthDiff(b, a);
	        }
	        // difference in months
	        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2,
	            adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        //check for negative zero, return zero if negative zero
	        return -(wholeMonthDiff + adjust) || 0;
	    }

	    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	    function toString() {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function toISOString(keepOffset) {
	        if (!this.isValid()) {
	            return null;
	        }
	        var utc = keepOffset !== true,
	            m = utc ? this.clone().utc() : this;
	        if (m.year() < 0 || m.year() > 9999) {
	            return formatMoment(
	                m,
	                utc
	                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
	                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
	            );
	        }
	        if (isFunction(Date.prototype.toISOString)) {
	            // native implementation is ~50x faster, use it when we can
	            if (utc) {
	                return this.toDate().toISOString();
	            } else {
	                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
	                    .toISOString()
	                    .replace('Z', formatMoment(m, 'Z'));
	            }
	        }
	        return formatMoment(
	            m,
	            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
	        );
	    }

	    /**
	     * Return a human readable representation of a moment that can
	     * also be evaluated to get a new moment which is the same
	     *
	     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	     */
	    function inspect() {
	        if (!this.isValid()) {
	            return 'moment.invalid(/* ' + this._i + ' */)';
	        }
	        var func = 'moment',
	            zone = '',
	            prefix,
	            year,
	            datetime,
	            suffix;
	        if (!this.isLocal()) {
	            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	            zone = 'Z';
	        }
	        prefix = '[' + func + '("]';
	        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
	        datetime = '-MM-DD[T]HH:mm:ss.SSS';
	        suffix = zone + '[")]';

	        return this.format(prefix + year + datetime + suffix);
	    }

	    function format(inputString) {
	        if (!inputString) {
	            inputString = this.isUtc()
	                ? hooks.defaultFormatUtc
	                : hooks.defaultFormat;
	        }
	        var output = formatMoment(this, inputString);
	        return this.localeData().postformat(output);
	    }

	    function from(time, withoutSuffix) {
	        if (
	            this.isValid() &&
	            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
	        ) {
	            return createDuration({ to: this, from: time })
	                .locale(this.locale())
	                .humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function fromNow(withoutSuffix) {
	        return this.from(createLocal(), withoutSuffix);
	    }

	    function to(time, withoutSuffix) {
	        if (
	            this.isValid() &&
	            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
	        ) {
	            return createDuration({ from: this, to: time })
	                .locale(this.locale())
	                .humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function toNow(withoutSuffix) {
	        return this.to(createLocal(), withoutSuffix);
	    }

	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale(key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData() {
	        return this._locale;
	    }

	    var MS_PER_SECOND = 1000,
	        MS_PER_MINUTE = 60 * MS_PER_SECOND,
	        MS_PER_HOUR = 60 * MS_PER_MINUTE,
	        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

	    // actual modulo - handles negative numbers (for dates before 1970):
	    function mod$1(dividend, divisor) {
	        return ((dividend % divisor) + divisor) % divisor;
	    }

	    function localStartOfDate(y, m, d) {
	        // the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
	        } else {
	            return new Date(y, m, d).valueOf();
	        }
	    }

	    function utcStartOfDate(y, m, d) {
	        // Date.UTC remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
	        } else {
	            return Date.UTC(y, m, d);
	        }
	    }

	    function startOf(units) {
	        var time, startOfDate;
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond' || !this.isValid()) {
	            return this;
	        }

	        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	        switch (units) {
	            case 'year':
	                time = startOfDate(this.year(), 0, 1);
	                break;
	            case 'quarter':
	                time = startOfDate(
	                    this.year(),
	                    this.month() - (this.month() % 3),
	                    1
	                );
	                break;
	            case 'month':
	                time = startOfDate(this.year(), this.month(), 1);
	                break;
	            case 'week':
	                time = startOfDate(
	                    this.year(),
	                    this.month(),
	                    this.date() - this.weekday()
	                );
	                break;
	            case 'isoWeek':
	                time = startOfDate(
	                    this.year(),
	                    this.month(),
	                    this.date() - (this.isoWeekday() - 1)
	                );
	                break;
	            case 'day':
	            case 'date':
	                time = startOfDate(this.year(), this.month(), this.date());
	                break;
	            case 'hour':
	                time = this._d.valueOf();
	                time -= mod$1(
	                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
	                    MS_PER_HOUR
	                );
	                break;
	            case 'minute':
	                time = this._d.valueOf();
	                time -= mod$1(time, MS_PER_MINUTE);
	                break;
	            case 'second':
	                time = this._d.valueOf();
	                time -= mod$1(time, MS_PER_SECOND);
	                break;
	        }

	        this._d.setTime(time);
	        hooks.updateOffset(this, true);
	        return this;
	    }

	    function endOf(units) {
	        var time, startOfDate;
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond' || !this.isValid()) {
	            return this;
	        }

	        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	        switch (units) {
	            case 'year':
	                time = startOfDate(this.year() + 1, 0, 1) - 1;
	                break;
	            case 'quarter':
	                time =
	                    startOfDate(
	                        this.year(),
	                        this.month() - (this.month() % 3) + 3,
	                        1
	                    ) - 1;
	                break;
	            case 'month':
	                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
	                break;
	            case 'week':
	                time =
	                    startOfDate(
	                        this.year(),
	                        this.month(),
	                        this.date() - this.weekday() + 7
	                    ) - 1;
	                break;
	            case 'isoWeek':
	                time =
	                    startOfDate(
	                        this.year(),
	                        this.month(),
	                        this.date() - (this.isoWeekday() - 1) + 7
	                    ) - 1;
	                break;
	            case 'day':
	            case 'date':
	                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
	                break;
	            case 'hour':
	                time = this._d.valueOf();
	                time +=
	                    MS_PER_HOUR -
	                    mod$1(
	                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
	                        MS_PER_HOUR
	                    ) -
	                    1;
	                break;
	            case 'minute':
	                time = this._d.valueOf();
	                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
	                break;
	            case 'second':
	                time = this._d.valueOf();
	                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
	                break;
	        }

	        this._d.setTime(time);
	        hooks.updateOffset(this, true);
	        return this;
	    }

	    function valueOf() {
	        return this._d.valueOf() - (this._offset || 0) * 60000;
	    }

	    function unix() {
	        return Math.floor(this.valueOf() / 1000);
	    }

	    function toDate() {
	        return new Date(this.valueOf());
	    }

	    function toArray() {
	        var m = this;
	        return [
	            m.year(),
	            m.month(),
	            m.date(),
	            m.hour(),
	            m.minute(),
	            m.second(),
	            m.millisecond(),
	        ];
	    }

	    function toObject() {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds(),
	        };
	    }

	    function toJSON() {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }

	    function isValid$2() {
	        return isValid(this);
	    }

	    function parsingFlags() {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt() {
	        return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict,
	        };
	    }

	    addFormatToken('N', 0, 0, 'eraAbbr');
	    addFormatToken('NN', 0, 0, 'eraAbbr');
	    addFormatToken('NNN', 0, 0, 'eraAbbr');
	    addFormatToken('NNNN', 0, 0, 'eraName');
	    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

	    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
	    addFormatToken('y', ['yy', 2], 0, 'eraYear');
	    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
	    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

	    addRegexToken('N', matchEraAbbr);
	    addRegexToken('NN', matchEraAbbr);
	    addRegexToken('NNN', matchEraAbbr);
	    addRegexToken('NNNN', matchEraName);
	    addRegexToken('NNNNN', matchEraNarrow);

	    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
	        input,
	        array,
	        config,
	        token
	    ) {
	        var era = config._locale.erasParse(input, token, config._strict);
	        if (era) {
	            getParsingFlags(config).era = era;
	        } else {
	            getParsingFlags(config).invalidEra = input;
	        }
	    });

	    addRegexToken('y', matchUnsigned);
	    addRegexToken('yy', matchUnsigned);
	    addRegexToken('yyy', matchUnsigned);
	    addRegexToken('yyyy', matchUnsigned);
	    addRegexToken('yo', matchEraYearOrdinal);

	    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
	    addParseToken(['yo'], function (input, array, config, token) {
	        var match;
	        if (config._locale._eraYearOrdinalRegex) {
	            match = input.match(config._locale._eraYearOrdinalRegex);
	        }

	        if (config._locale.eraYearOrdinalParse) {
	            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
	        } else {
	            array[YEAR] = parseInt(input, 10);
	        }
	    });

	    function localeEras(m, format) {
	        var i,
	            l,
	            date,
	            eras = this._eras || getLocale('en')._eras;
	        for (i = 0, l = eras.length; i < l; ++i) {
	            switch (typeof eras[i].since) {
	                case 'string':
	                    // truncate time
	                    date = hooks(eras[i].since).startOf('day');
	                    eras[i].since = date.valueOf();
	                    break;
	            }

	            switch (typeof eras[i].until) {
	                case 'undefined':
	                    eras[i].until = +Infinity;
	                    break;
	                case 'string':
	                    // truncate time
	                    date = hooks(eras[i].until).startOf('day').valueOf();
	                    eras[i].until = date.valueOf();
	                    break;
	            }
	        }
	        return eras;
	    }

	    function localeErasParse(eraName, format, strict) {
	        var i,
	            l,
	            eras = this.eras(),
	            name,
	            abbr,
	            narrow;
	        eraName = eraName.toUpperCase();

	        for (i = 0, l = eras.length; i < l; ++i) {
	            name = eras[i].name.toUpperCase();
	            abbr = eras[i].abbr.toUpperCase();
	            narrow = eras[i].narrow.toUpperCase();

	            if (strict) {
	                switch (format) {
	                    case 'N':
	                    case 'NN':
	                    case 'NNN':
	                        if (abbr === eraName) {
	                            return eras[i];
	                        }
	                        break;

	                    case 'NNNN':
	                        if (name === eraName) {
	                            return eras[i];
	                        }
	                        break;

	                    case 'NNNNN':
	                        if (narrow === eraName) {
	                            return eras[i];
	                        }
	                        break;
	                }
	            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
	                return eras[i];
	            }
	        }
	    }

	    function localeErasConvertYear(era, year) {
	        var dir = era.since <= era.until ? +1 : -1;
	        if (year === undefined) {
	            return hooks(era.since).year();
	        } else {
	            return hooks(era.since).year() + (year - era.offset) * dir;
	        }
	    }

	    function getEraName() {
	        var i,
	            l,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (eras[i].since <= val && val <= eras[i].until) {
	                return eras[i].name;
	            }
	            if (eras[i].until <= val && val <= eras[i].since) {
	                return eras[i].name;
	            }
	        }

	        return '';
	    }

	    function getEraNarrow() {
	        var i,
	            l,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (eras[i].since <= val && val <= eras[i].until) {
	                return eras[i].narrow;
	            }
	            if (eras[i].until <= val && val <= eras[i].since) {
	                return eras[i].narrow;
	            }
	        }

	        return '';
	    }

	    function getEraAbbr() {
	        var i,
	            l,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (eras[i].since <= val && val <= eras[i].until) {
	                return eras[i].abbr;
	            }
	            if (eras[i].until <= val && val <= eras[i].since) {
	                return eras[i].abbr;
	            }
	        }

	        return '';
	    }

	    function getEraYear() {
	        var i,
	            l,
	            dir,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            dir = eras[i].since <= eras[i].until ? +1 : -1;

	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (
	                (eras[i].since <= val && val <= eras[i].until) ||
	                (eras[i].until <= val && val <= eras[i].since)
	            ) {
	                return (
	                    (this.year() - hooks(eras[i].since).year()) * dir +
	                    eras[i].offset
	                );
	            }
	        }

	        return this.year();
	    }

	    function erasNameRegex(isStrict) {
	        if (!hasOwnProp(this, '_erasNameRegex')) {
	            computeErasParse.call(this);
	        }
	        return isStrict ? this._erasNameRegex : this._erasRegex;
	    }

	    function erasAbbrRegex(isStrict) {
	        if (!hasOwnProp(this, '_erasAbbrRegex')) {
	            computeErasParse.call(this);
	        }
	        return isStrict ? this._erasAbbrRegex : this._erasRegex;
	    }

	    function erasNarrowRegex(isStrict) {
	        if (!hasOwnProp(this, '_erasNarrowRegex')) {
	            computeErasParse.call(this);
	        }
	        return isStrict ? this._erasNarrowRegex : this._erasRegex;
	    }

	    function matchEraAbbr(isStrict, locale) {
	        return locale.erasAbbrRegex(isStrict);
	    }

	    function matchEraName(isStrict, locale) {
	        return locale.erasNameRegex(isStrict);
	    }

	    function matchEraNarrow(isStrict, locale) {
	        return locale.erasNarrowRegex(isStrict);
	    }

	    function matchEraYearOrdinal(isStrict, locale) {
	        return locale._eraYearOrdinalRegex || matchUnsigned;
	    }

	    function computeErasParse() {
	        var abbrPieces = [],
	            namePieces = [],
	            narrowPieces = [],
	            mixedPieces = [],
	            i,
	            l,
	            eras = this.eras();

	        for (i = 0, l = eras.length; i < l; ++i) {
	            namePieces.push(regexEscape(eras[i].name));
	            abbrPieces.push(regexEscape(eras[i].abbr));
	            narrowPieces.push(regexEscape(eras[i].narrow));

	            mixedPieces.push(regexEscape(eras[i].name));
	            mixedPieces.push(regexEscape(eras[i].abbr));
	            mixedPieces.push(regexEscape(eras[i].narrow));
	        }

	        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
	        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
	        this._erasNarrowRegex = new RegExp(
	            '^(' + narrowPieces.join('|') + ')',
	            'i'
	        );
	    }

	    // FORMATTING

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken(token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg', 'weekYear');
	    addWeekYearFormatToken('ggggg', 'weekYear');
	    addWeekYearFormatToken('GGGG', 'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PRIORITY

	    addUnitPriority('weekYear', 1);
	    addUnitPriority('isoWeekYear', 1);

	    // PARSING

	    addRegexToken('G', matchSigned);
	    addRegexToken('g', matchSigned);
	    addRegexToken('GG', match1to2, match2);
	    addRegexToken('gg', match1to2, match2);
	    addRegexToken('GGGG', match1to4, match4);
	    addRegexToken('gggg', match1to4, match4);
	    addRegexToken('GGGGG', match1to6, match6);
	    addRegexToken('ggggg', match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
	        input,
	        week,
	        config,
	        token
	    ) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = hooks.parseTwoDigitYear(input);
	    });

	    // MOMENTS

	    function getSetWeekYear(input) {
	        return getSetWeekYearHelper.call(
	            this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy
	        );
	    }

	    function getSetISOWeekYear(input) {
	        return getSetWeekYearHelper.call(
	            this,
	            input,
	            this.isoWeek(),
	            this.isoWeekday(),
	            1,
	            4
	        );
	    }

	    function getISOWeeksInYear() {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getISOWeeksInISOWeekYear() {
	        return weeksInYear(this.isoWeekYear(), 1, 4);
	    }

	    function getWeeksInYear() {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getWeeksInWeekYear() {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }

	    // FORMATTING

	    addFormatToken('Q', 0, 'Qo', 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PRIORITY

	    addUnitPriority('quarter', 7);

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter(input) {
	        return input == null
	            ? Math.ceil((this.month() + 1) / 3)
	            : this.month((input - 1) * 3 + (this.month() % 3));
	    }

	    // FORMATTING

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PRIORITY
	    addUnitPriority('date', 9);

	    // PARSING

	    addRegexToken('D', match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        // TODO: Remove "ordinalParse" fallback in next major release.
	        return isStrict
	            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
	            : locale._dayOfMonthOrdinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0]);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PRIORITY
	    addUnitPriority('dayOfYear', 4);

	    // PARSING

	    addRegexToken('DDD', match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    // MOMENTS

	    function getSetDayOfYear(input) {
	        var dayOfYear =
	            Math.round(
	                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
	            ) + 1;
	        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
	    }

	    // FORMATTING

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PRIORITY

	    addUnitPriority('minute', 14);

	    // PARSING

	    addRegexToken('m', match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PRIORITY

	    addUnitPriority('second', 15);

	    // PARSING

	    addRegexToken('s', match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });

	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PRIORITY

	    addUnitPriority('millisecond', 16);

	    // PARSING

	    addRegexToken('S', match1to3, match1);
	    addRegexToken('SS', match1to3, match2);
	    addRegexToken('SSS', match1to3, match3);

	    var token, getSetMillisecond;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }

	    getSetMillisecond = makeGetSet('Milliseconds', false);

	    // FORMATTING

	    addFormatToken('z', 0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr() {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName() {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var proto = Moment.prototype;

	    proto.add = add;
	    proto.calendar = calendar$1;
	    proto.clone = clone;
	    proto.diff = diff;
	    proto.endOf = endOf;
	    proto.format = format;
	    proto.from = from;
	    proto.fromNow = fromNow;
	    proto.to = to;
	    proto.toNow = toNow;
	    proto.get = stringGet;
	    proto.invalidAt = invalidAt;
	    proto.isAfter = isAfter;
	    proto.isBefore = isBefore;
	    proto.isBetween = isBetween;
	    proto.isSame = isSame;
	    proto.isSameOrAfter = isSameOrAfter;
	    proto.isSameOrBefore = isSameOrBefore;
	    proto.isValid = isValid$2;
	    proto.lang = lang;
	    proto.locale = locale;
	    proto.localeData = localeData;
	    proto.max = prototypeMax;
	    proto.min = prototypeMin;
	    proto.parsingFlags = parsingFlags;
	    proto.set = stringSet;
	    proto.startOf = startOf;
	    proto.subtract = subtract;
	    proto.toArray = toArray;
	    proto.toObject = toObject;
	    proto.toDate = toDate;
	    proto.toISOString = toISOString;
	    proto.inspect = inspect;
	    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
	        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
	            return 'Moment<' + this.format() + '>';
	        };
	    }
	    proto.toJSON = toJSON;
	    proto.toString = toString;
	    proto.unix = unix;
	    proto.valueOf = valueOf;
	    proto.creationData = creationData;
	    proto.eraName = getEraName;
	    proto.eraNarrow = getEraNarrow;
	    proto.eraAbbr = getEraAbbr;
	    proto.eraYear = getEraYear;
	    proto.year = getSetYear;
	    proto.isLeapYear = getIsLeapYear;
	    proto.weekYear = getSetWeekYear;
	    proto.isoWeekYear = getSetISOWeekYear;
	    proto.quarter = proto.quarters = getSetQuarter;
	    proto.month = getSetMonth;
	    proto.daysInMonth = getDaysInMonth;
	    proto.week = proto.weeks = getSetWeek;
	    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
	    proto.weeksInYear = getWeeksInYear;
	    proto.weeksInWeekYear = getWeeksInWeekYear;
	    proto.isoWeeksInYear = getISOWeeksInYear;
	    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
	    proto.date = getSetDayOfMonth;
	    proto.day = proto.days = getSetDayOfWeek;
	    proto.weekday = getSetLocaleDayOfWeek;
	    proto.isoWeekday = getSetISODayOfWeek;
	    proto.dayOfYear = getSetDayOfYear;
	    proto.hour = proto.hours = getSetHour;
	    proto.minute = proto.minutes = getSetMinute;
	    proto.second = proto.seconds = getSetSecond;
	    proto.millisecond = proto.milliseconds = getSetMillisecond;
	    proto.utcOffset = getSetOffset;
	    proto.utc = setOffsetToUTC;
	    proto.local = setOffsetToLocal;
	    proto.parseZone = setOffsetToParsedOffset;
	    proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    proto.isDST = isDaylightSavingTime;
	    proto.isLocal = isLocal;
	    proto.isUtcOffset = isUtcOffset;
	    proto.isUtc = isUtc;
	    proto.isUTC = isUtc;
	    proto.zoneAbbr = getZoneAbbr;
	    proto.zoneName = getZoneName;
	    proto.dates = deprecate(
	        'dates accessor is deprecated. Use date instead.',
	        getSetDayOfMonth
	    );
	    proto.months = deprecate(
	        'months accessor is deprecated. Use month instead',
	        getSetMonth
	    );
	    proto.years = deprecate(
	        'years accessor is deprecated. Use year instead',
	        getSetYear
	    );
	    proto.zone = deprecate(
	        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
	        getSetZone
	    );
	    proto.isDSTShifted = deprecate(
	        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
	        isDaylightSavingTimeShifted
	    );

	    function createUnix(input) {
	        return createLocal(input * 1000);
	    }

	    function createInZone() {
	        return createLocal.apply(null, arguments).parseZone();
	    }

	    function preParsePostFormat(string) {
	        return string;
	    }

	    var proto$1 = Locale.prototype;

	    proto$1.calendar = calendar;
	    proto$1.longDateFormat = longDateFormat;
	    proto$1.invalidDate = invalidDate;
	    proto$1.ordinal = ordinal;
	    proto$1.preparse = preParsePostFormat;
	    proto$1.postformat = preParsePostFormat;
	    proto$1.relativeTime = relativeTime;
	    proto$1.pastFuture = pastFuture;
	    proto$1.set = set;
	    proto$1.eras = localeEras;
	    proto$1.erasParse = localeErasParse;
	    proto$1.erasConvertYear = localeErasConvertYear;
	    proto$1.erasAbbrRegex = erasAbbrRegex;
	    proto$1.erasNameRegex = erasNameRegex;
	    proto$1.erasNarrowRegex = erasNarrowRegex;

	    proto$1.months = localeMonths;
	    proto$1.monthsShort = localeMonthsShort;
	    proto$1.monthsParse = localeMonthsParse;
	    proto$1.monthsRegex = monthsRegex;
	    proto$1.monthsShortRegex = monthsShortRegex;
	    proto$1.week = localeWeek;
	    proto$1.firstDayOfYear = localeFirstDayOfYear;
	    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	    proto$1.weekdays = localeWeekdays;
	    proto$1.weekdaysMin = localeWeekdaysMin;
	    proto$1.weekdaysShort = localeWeekdaysShort;
	    proto$1.weekdaysParse = localeWeekdaysParse;

	    proto$1.weekdaysRegex = weekdaysRegex;
	    proto$1.weekdaysShortRegex = weekdaysShortRegex;
	    proto$1.weekdaysMinRegex = weekdaysMinRegex;

	    proto$1.isPM = localeIsPM;
	    proto$1.meridiem = localeMeridiem;

	    function get$1(format, index, field, setter) {
	        var locale = getLocale(),
	            utc = createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function listMonthsImpl(format, index, field) {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return get$1(format, index, field, 'month');
	        }

	        var i,
	            out = [];
	        for (i = 0; i < 12; i++) {
	            out[i] = get$1(format, i, field, 'month');
	        }
	        return out;
	    }

	    // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)
	    function listWeekdaysImpl(localeSorted, format, index, field) {
	        if (typeof localeSorted === 'boolean') {
	            if (isNumber(format)) {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        } else {
	            format = localeSorted;
	            index = format;
	            localeSorted = false;

	            if (isNumber(format)) {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        }

	        var locale = getLocale(),
	            shift = localeSorted ? locale._week.dow : 0,
	            i,
	            out = [];

	        if (index != null) {
	            return get$1(format, (index + shift) % 7, field, 'day');
	        }

	        for (i = 0; i < 7; i++) {
	            out[i] = get$1(format, (i + shift) % 7, field, 'day');
	        }
	        return out;
	    }

	    function listMonths(format, index) {
	        return listMonthsImpl(format, index, 'months');
	    }

	    function listMonthsShort(format, index) {
	        return listMonthsImpl(format, index, 'monthsShort');
	    }

	    function listWeekdays(localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }

	    function listWeekdaysShort(localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }

	    function listWeekdaysMin(localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }

	    getSetGlobalLocale('en', {
	        eras: [
	            {
	                since: '0001-01-01',
	                until: +Infinity,
	                offset: 1,
	                name: 'Anno Domini',
	                narrow: 'AD',
	                abbr: 'AD',
	            },
	            {
	                since: '0000-12-31',
	                until: -Infinity,
	                offset: 1,
	                name: 'Before Christ',
	                narrow: 'BC',
	                abbr: 'BC',
	            },
	        ],
	        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal: function (number) {
	            var b = number % 10,
	                output =
	                    toInt((number % 100) / 10) === 1
	                        ? 'th'
	                        : b === 1
	                        ? 'st'
	                        : b === 2
	                        ? 'nd'
	                        : b === 3
	                        ? 'rd'
	                        : 'th';
	            return number + output;
	        },
	    });

	    // Side effect imports

	    hooks.lang = deprecate(
	        'moment.lang is deprecated. Use moment.locale instead.',
	        getSetGlobalLocale
	    );
	    hooks.langData = deprecate(
	        'moment.langData is deprecated. Use moment.localeData instead.',
	        getLocale
	    );

	    var mathAbs = Math.abs;

	    function abs() {
	        var data = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days = mathAbs(this._days);
	        this._months = mathAbs(this._months);

	        data.milliseconds = mathAbs(data.milliseconds);
	        data.seconds = mathAbs(data.seconds);
	        data.minutes = mathAbs(data.minutes);
	        data.hours = mathAbs(data.hours);
	        data.months = mathAbs(data.months);
	        data.years = mathAbs(data.years);

	        return this;
	    }

	    function addSubtract$1(duration, input, value, direction) {
	        var other = createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days += direction * other._days;
	        duration._months += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function add$1(input, value) {
	        return addSubtract$1(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function subtract$1(input, value) {
	        return addSubtract$1(this, input, value, -1);
	    }

	    function absCeil(number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble() {
	        var milliseconds = this._milliseconds,
	            days = this._days,
	            months = this._months,
	            data = this._data,
	            seconds,
	            minutes,
	            hours,
	            years,
	            monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (
	            !(
	                (milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0)
	            )
	        ) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds = absFloor(milliseconds / 1000);
	        data.seconds = seconds % 60;

	        minutes = absFloor(seconds / 60);
	        data.minutes = minutes % 60;

	        hours = absFloor(minutes / 60);
	        data.hours = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days = days;
	        data.months = months;
	        data.years = years;

	        return this;
	    }

	    function daysToMonths(days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return (days * 4800) / 146097;
	    }

	    function monthsToDays(months) {
	        // the reverse of daysToMonths
	        return (months * 146097) / 4800;
	    }

	    function as(units) {
	        if (!this.isValid()) {
	            return NaN;
	        }
	        var days,
	            months,
	            milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'quarter' || units === 'year') {
	            days = this._days + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            switch (units) {
	                case 'month':
	                    return months;
	                case 'quarter':
	                    return months / 3;
	                case 'year':
	                    return months / 12;
	            }
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week':
	                    return days / 7 + milliseconds / 6048e5;
	                case 'day':
	                    return days + milliseconds / 864e5;
	                case 'hour':
	                    return days * 24 + milliseconds / 36e5;
	                case 'minute':
	                    return days * 1440 + milliseconds / 6e4;
	                case 'second':
	                    return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond':
	                    return Math.floor(days * 864e5) + milliseconds;
	                default:
	                    throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function valueOf$1() {
	        if (!this.isValid()) {
	            return NaN;
	        }
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs(alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms'),
	        asSeconds = makeAs('s'),
	        asMinutes = makeAs('m'),
	        asHours = makeAs('h'),
	        asDays = makeAs('d'),
	        asWeeks = makeAs('w'),
	        asMonths = makeAs('M'),
	        asQuarters = makeAs('Q'),
	        asYears = makeAs('y');

	    function clone$1() {
	        return createDuration(this);
	    }

	    function get$2(units) {
	        units = normalizeUnits(units);
	        return this.isValid() ? this[units + 's']() : NaN;
	    }

	    function makeGetter(name) {
	        return function () {
	            return this.isValid() ? this._data[name] : NaN;
	        };
	    }

	    var milliseconds = makeGetter('milliseconds'),
	        seconds = makeGetter('seconds'),
	        minutes = makeGetter('minutes'),
	        hours = makeGetter('hours'),
	        days = makeGetter('days'),
	        months = makeGetter('months'),
	        years = makeGetter('years');

	    function weeks() {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round,
	        thresholds = {
	            ss: 44, // a few seconds to seconds
	            s: 45, // seconds to minute
	            m: 45, // minutes to hour
	            h: 22, // hours to day
	            d: 26, // days to month/week
	            w: null, // weeks to month
	            M: 11, // months to year
	        };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
	        var duration = createDuration(posNegDuration).abs(),
	            seconds = round(duration.as('s')),
	            minutes = round(duration.as('m')),
	            hours = round(duration.as('h')),
	            days = round(duration.as('d')),
	            months = round(duration.as('M')),
	            weeks = round(duration.as('w')),
	            years = round(duration.as('y')),
	            a =
	                (seconds <= thresholds.ss && ['s', seconds]) ||
	                (seconds < thresholds.s && ['ss', seconds]) ||
	                (minutes <= 1 && ['m']) ||
	                (minutes < thresholds.m && ['mm', minutes]) ||
	                (hours <= 1 && ['h']) ||
	                (hours < thresholds.h && ['hh', hours]) ||
	                (days <= 1 && ['d']) ||
	                (days < thresholds.d && ['dd', days]);

	        if (thresholds.w != null) {
	            a =
	                a ||
	                (weeks <= 1 && ['w']) ||
	                (weeks < thresholds.w && ['ww', weeks]);
	        }
	        a = a ||
	            (months <= 1 && ['M']) ||
	            (months < thresholds.M && ['MM', months]) ||
	            (years <= 1 && ['y']) || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set the rounding function for relative time strings
	    function getSetRelativeTimeRounding(roundingFunction) {
	        if (roundingFunction === undefined) {
	            return round;
	        }
	        if (typeof roundingFunction === 'function') {
	            round = roundingFunction;
	            return true;
	        }
	        return false;
	    }

	    // This function allows you to set a threshold for relative time strings
	    function getSetRelativeTimeThreshold(threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        if (threshold === 's') {
	            thresholds.ss = limit - 1;
	        }
	        return true;
	    }

	    function humanize(argWithSuffix, argThresholds) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }

	        var withSuffix = false,
	            th = thresholds,
	            locale,
	            output;

	        if (typeof argWithSuffix === 'object') {
	            argThresholds = argWithSuffix;
	            argWithSuffix = false;
	        }
	        if (typeof argWithSuffix === 'boolean') {
	            withSuffix = argWithSuffix;
	        }
	        if (typeof argThresholds === 'object') {
	            th = Object.assign({}, thresholds, argThresholds);
	            if (argThresholds.s != null && argThresholds.ss == null) {
	                th.ss = argThresholds.s - 1;
	            }
	        }

	        locale = this.localeData();
	        output = relativeTime$1(this, !withSuffix, th, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var abs$1 = Math.abs;

	    function sign(x) {
	        return (x > 0) - (x < 0) || +x;
	    }

	    function toISOString$1() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }

	        var seconds = abs$1(this._milliseconds) / 1000,
	            days = abs$1(this._days),
	            months = abs$1(this._months),
	            minutes,
	            hours,
	            years,
	            s,
	            total = this.asSeconds(),
	            totalSign,
	            ymSign,
	            daysSign,
	            hmsSign;

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes = absFloor(seconds / 60);
	        hours = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

	        totalSign = total < 0 ? '-' : '';
	        ymSign = sign(this._months) !== sign(total) ? '-' : '';
	        daysSign = sign(this._days) !== sign(total) ? '-' : '';
	        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

	        return (
	            totalSign +
	            'P' +
	            (years ? ymSign + years + 'Y' : '') +
	            (months ? ymSign + months + 'M' : '') +
	            (days ? daysSign + days + 'D' : '') +
	            (hours || minutes || seconds ? 'T' : '') +
	            (hours ? hmsSign + hours + 'H' : '') +
	            (minutes ? hmsSign + minutes + 'M' : '') +
	            (seconds ? hmsSign + s + 'S' : '')
	        );
	    }

	    var proto$2 = Duration.prototype;

	    proto$2.isValid = isValid$1;
	    proto$2.abs = abs;
	    proto$2.add = add$1;
	    proto$2.subtract = subtract$1;
	    proto$2.as = as;
	    proto$2.asMilliseconds = asMilliseconds;
	    proto$2.asSeconds = asSeconds;
	    proto$2.asMinutes = asMinutes;
	    proto$2.asHours = asHours;
	    proto$2.asDays = asDays;
	    proto$2.asWeeks = asWeeks;
	    proto$2.asMonths = asMonths;
	    proto$2.asQuarters = asQuarters;
	    proto$2.asYears = asYears;
	    proto$2.valueOf = valueOf$1;
	    proto$2._bubble = bubble;
	    proto$2.clone = clone$1;
	    proto$2.get = get$2;
	    proto$2.milliseconds = milliseconds;
	    proto$2.seconds = seconds;
	    proto$2.minutes = minutes;
	    proto$2.hours = hours;
	    proto$2.days = days;
	    proto$2.weeks = weeks;
	    proto$2.months = months;
	    proto$2.years = years;
	    proto$2.humanize = humanize;
	    proto$2.toISOString = toISOString$1;
	    proto$2.toString = toISOString$1;
	    proto$2.toJSON = toISOString$1;
	    proto$2.locale = locale;
	    proto$2.localeData = localeData;

	    proto$2.toIsoString = deprecate(
	        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
	        toISOString$1
	    );
	    proto$2.lang = lang;

	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    //! moment.js

	    hooks.version = '2.29.1';

	    setHookCallback(createLocal);

	    hooks.fn = proto;
	    hooks.min = min;
	    hooks.max = max;
	    hooks.now = now;
	    hooks.utc = createUTC;
	    hooks.unix = createUnix;
	    hooks.months = listMonths;
	    hooks.isDate = isDate;
	    hooks.locale = getSetGlobalLocale;
	    hooks.invalid = createInvalid;
	    hooks.duration = createDuration;
	    hooks.isMoment = isMoment;
	    hooks.weekdays = listWeekdays;
	    hooks.parseZone = createInZone;
	    hooks.localeData = getLocale;
	    hooks.isDuration = isDuration;
	    hooks.monthsShort = listMonthsShort;
	    hooks.weekdaysMin = listWeekdaysMin;
	    hooks.defineLocale = defineLocale;
	    hooks.updateLocale = updateLocale;
	    hooks.locales = listLocales;
	    hooks.weekdaysShort = listWeekdaysShort;
	    hooks.normalizeUnits = normalizeUnits;
	    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	    hooks.calendarFormat = getCalendarFormat;
	    hooks.prototype = proto;

	    // currently HTML5 input type only supports 24-hour formats
	    hooks.HTML5_FMT = {
	        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
	        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
	        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
	        DATE: 'YYYY-MM-DD', // <input type="date" />
	        TIME: 'HH:mm', // <input type="time" />
	        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
	        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
	        WEEK: 'GGGG-[W]WW', // <input type="week" />
	        MONTH: 'YYYY-MM', // <input type="month" />
	    };

	    return hooks;

	})));
} (moment$1));

var moment = moment$1.exports;

// formatToTime = 'YYYY-MM-DD HH:mm:ss'
// formatToMinute = 'YYYY-MM-DD HH:mm'
// formatToDate = 'YYYY-MM-DD'

const today = () => [moment().startOf('day'), moment().endOf('day')];

const yesterday = () => [
	moment().subtract(1, 'day').startOf('day'),
	moment().endOf('day'),
];

const thisWeek = () => [
	moment().isoWeekday(1).startOf('day'),
	moment().endOf('day'),
];

const pastWeek = () => [
	moment().isoWeekday(-6).startOf('day'),
	moment().isoWeekday(0).endOf('day'),
];

const thisMonth = () => [moment().date(1).startOf('day'), moment().endOf('day')];

const pastMonth = () => [
	moment()
		.month(moment().month() - 1)
		.date(1)
		.startOf('day'),
	moment()
		.month(moment().month() - 1)
		.endOf('month'),
];

// const msTranslate = (ms = 0) => {
// 	const sec = 1000
// 	const min = sec * 60
// 	// const hour = min * 60
// 	// const day = hour * 24
// 	// const cDay = Math.floor(ms / day)
// 	// const cHour = Math.floor((ms / hour) % 24)
// 	const cMin = Math.floor((ms / min) % 60)
// 	const cSec = Math.floor((ms / sec) % 60)
//
// 	// return `${cDay}天 ${cHour}時 ${cMin}分 ${cSec}秒`
// 	if (cMin > 0) {
// 		return `${cMin}${t('簡寫:分')} ${cSec}${t('簡寫:秒')}`
// 	} else {
// 		return `${cSec}${t('簡寫:秒')}`
// 	}
// }

var mtime = {
	today,
	yesterday,
	thisWeek,
	pastWeek,
	thisMonth,
	pastMonth,
};

const start$2 =
	state =>
	(callback, delay = 0) => {
		stop$2(state)();
		state.timer = setTimeout(() => callback(), delay);
	};

const startSync =
	state =>
	(promiseFun, delay = 0) => {
		return new Promise((resolve, reject) => {
			stop$2(state)();
			state.timer = setTimeout(async () => {
				try {
					const res = await promiseFun();
					state.timer = null;
					resolve(res);
				} catch (err) {
					console.error(err);
					state.timer = null;
					reject(err);
				}
			}, delay);
		})
	};

const stop$2 = state => () => {
	if (state.timer != null) {
		clearTimeout(state.timer);
		state.timer = null;
	}
};

const timeout = () => {
	const state = { timer: null };
	return {
		start: start$2(state),
		startSync: startSync(state),
		stop: stop$2(state),
	}
};

const start$1 =
	state =>
	(callback, delay = 0) => {
		stop$1(state)();
		state.timer = setInterval(() => callback(), delay);
	};

const stop$1 = state => () => {
	if (state.timer != null) {
		clearInterval(state.timer);
		state.timer = null;
	}
};

const interval = () => {
	const state = { timer: null };
	return {
		start: start$1(state),
		stop: stop$1(state),
	}
};

const start = state => callback => {
	function run() {
		callback();
		state.timer = requestAnimationFrame(run);
	}

	state.timer = requestAnimationFrame(run);
};

const stop = state => () => {
	cancelAnimationFrame(state.timer);
};

const aniFrame = () => {
	let state = { timer: null };
	return {
		start: start(state),
		stop: stop(state),
	}
};

const generateId = (length = 6) => {
	let result = '';
	const characters =
		'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	const charactersLength = characters.length;
	for (let i = 0; i < length; i++) {
		result += characters.charAt(Math.floor(Math.random() * charactersLength));
	}
	return result
};

const mergeWords = (...conditionTextArr) => {
	if (!conditionTextArr) return ''

	let resultWord = '';
	let first = true;
	for (let i = 0; i < conditionTextArr.length; i++) {
		const e = conditionTextArr[i];
		if (e) {
			if (first) {
				first = false;
				resultWord += e;
			} else {
				resultWord += ' ' + e;
			}
		}
	}
	return resultWord
};

const findNestedDynamicObj = (obj, key) => {
	if (typeof obj !== 'object') {
		console.warn(`[findNestedDynamicObj::warn] obj 請傳 {}`);
		return key
	}
	const _key = typeof key === 'string' ? key : String(key);
	const ks = _key.split('.');
	let el = obj[_key] || key;

	if (typeof el !== 'object' && ks.length < 2) {
		return el
	}

	el = obj[ks[0]];
	for (let i = 1; i < ks.length; i++) {
		if (el == null) {
			break
		}

		const k = ks[i];
		el = el[k] || key;

		if (typeof el !== 'object') {
			if (i !== ks.length - 1) {
				el = key;
			}
			break
		}
	}

	return el || key
};

exports.aniFrame = aniFrame;
exports.checkIncludeText = checkIncludeText;
exports.checkSameChinese = checkSameChinese;
exports.createEnum = createEnum;
exports.declareEnum = declareEnum;
exports.findNestedDynamicObj = findNestedDynamicObj;
exports.generateId = generateId;
exports.interval = interval;
exports.mergeWords = mergeWords;
exports.mtime = mtime;
exports.stepPrice = stepPrice;
exports.timeout = timeout;
exports.toSimple = toSimple;
exports.toTraditional = toTraditional;
