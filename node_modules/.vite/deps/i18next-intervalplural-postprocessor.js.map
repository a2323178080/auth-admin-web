{
  "version": 3,
  "sources": ["../../i18next-intervalplural-postprocessor/dist/es/index.js"],
  "sourcesContent": ["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction intervalMatches(interval, count) {\n  if (interval.indexOf('-') > -1) {\n    var p = interval.split('-');\n    if (p[1] === 'inf') {\n      var from = parseInt(p[0], 10);\n      return count >= from;\n    } else {\n      var _from = parseInt(p[0], 10);\n      var to = parseInt(p[1], 10);\n      return count >= _from && count <= to;\n    }\n  } else {\n    var match = parseInt(interval, 10);\n    return match === count;\n  }\n}\n\nexport default {\n  name: 'interval',\n  type: 'postProcessor',\n\n  options: {\n    intervalSeparator: ';',\n    intervalRegex: /\\((\\S*)\\).*?\\[((.|\\n)*)\\]/,\n    intervalSuffix: '_interval'\n  },\n\n  setOptions: function setOptions(options) {\n    this.options = _extends({}, this.options, options);\n  },\n  process: function process(value, key, options, translator) {\n    var _this = this;\n\n    var p = value.split(this.options.intervalSeparator);\n\n    var found = void 0;\n    p.forEach(function (iv) {\n      if (found) return;\n      var match = _this.options.intervalRegex.exec(iv);\n\n      if (match && intervalMatches(match[1], options.count || 0)) {\n        found = match[2];\n      }\n    });\n\n    // not found fallback to classical plural\n    if (!found) {\n      var newOptions = _extends({}, options);\n      if (typeof newOptions.postProcess === 'string') {\n        delete newOptions.postProcess;\n      } else {\n        var index = newOptions.postProcess.indexOf('interval'); // <-- Not supported in <IE9\n        if (index !== -1) newOptions.postProcess.splice(index, 1);\n      }\n\n      var newKeys = void 0;\n      if (typeof key === 'string') {\n        newKeys = key.replace(this.options.intervalSuffix, '');\n      } else if (key.length > -1) {\n        newKeys = key.map(function (k) {\n          return k.replace(_this.options.intervalSuffix, '');\n        });\n      }\n      if (newKeys) found = translator.translate(newKeys, newOptions);\n    }\n\n    return found || value;\n  }\n};"],
  "mappings": ";;;AAAA,IAAI,WAAW,OAAO,UAAU,SAAU,QAAQ;AAAE,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAAE,QAAI,SAAS,UAAU,CAAC;AAAG,aAAS,OAAO,QAAQ;AAAE,UAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,GAAG,GAAG;AAAE,eAAO,GAAG,IAAI,OAAO,GAAG;AAAA,MAAG;AAAA,IAAE;AAAA,EAAE;AAAE,SAAO;AAAQ;AAE/P,SAAS,gBAAgB,UAAU,OAAO;AACxC,MAAI,SAAS,QAAQ,GAAG,IAAI,IAAI;AAC9B,QAAI,IAAI,SAAS,MAAM,GAAG;AAC1B,QAAI,EAAE,CAAC,MAAM,OAAO;AAClB,UAAI,OAAO,SAAS,EAAE,CAAC,GAAG,EAAE;AAC5B,aAAO,SAAS;AAAA,IAClB,OAAO;AACL,UAAI,QAAQ,SAAS,EAAE,CAAC,GAAG,EAAE;AAC7B,UAAI,KAAK,SAAS,EAAE,CAAC,GAAG,EAAE;AAC1B,aAAO,SAAS,SAAS,SAAS;AAAA,IACpC;AAAA,EACF,OAAO;AACL,QAAI,QAAQ,SAAS,UAAU,EAAE;AACjC,WAAO,UAAU;AAAA,EACnB;AACF;AAEA,IAAO,aAAQ;AAAA,EACb,MAAM;AAAA,EACN,MAAM;AAAA,EAEN,SAAS;AAAA,IACP,mBAAmB;AAAA,IACnB,eAAe;AAAA,IACf,gBAAgB;AAAA,EAClB;AAAA,EAEA,YAAY,SAAS,WAAW,SAAS;AACvC,SAAK,UAAU,SAAS,CAAC,GAAG,KAAK,SAAS,OAAO;AAAA,EACnD;AAAA,EACA,SAAS,SAAS,QAAQ,OAAO,KAAK,SAAS,YAAY;AACzD,QAAI,QAAQ;AAEZ,QAAI,IAAI,MAAM,MAAM,KAAK,QAAQ,iBAAiB;AAElD,QAAI,QAAQ;AACZ,MAAE,QAAQ,SAAU,IAAI;AACtB,UAAI;AAAO;AACX,UAAI,QAAQ,MAAM,QAAQ,cAAc,KAAK,EAAE;AAE/C,UAAI,SAAS,gBAAgB,MAAM,CAAC,GAAG,QAAQ,SAAS,CAAC,GAAG;AAC1D,gBAAQ,MAAM,CAAC;AAAA,MACjB;AAAA,IACF,CAAC;AAGD,QAAI,CAAC,OAAO;AACV,UAAI,aAAa,SAAS,CAAC,GAAG,OAAO;AACrC,UAAI,OAAO,WAAW,gBAAgB,UAAU;AAC9C,eAAO,WAAW;AAAA,MACpB,OAAO;AACL,YAAI,QAAQ,WAAW,YAAY,QAAQ,UAAU;AACrD,YAAI,UAAU;AAAI,qBAAW,YAAY,OAAO,OAAO,CAAC;AAAA,MAC1D;AAEA,UAAI,UAAU;AACd,UAAI,OAAO,QAAQ,UAAU;AAC3B,kBAAU,IAAI,QAAQ,KAAK,QAAQ,gBAAgB,EAAE;AAAA,MACvD,WAAW,IAAI,SAAS,IAAI;AAC1B,kBAAU,IAAI,IAAI,SAAU,GAAG;AAC7B,iBAAO,EAAE,QAAQ,MAAM,QAAQ,gBAAgB,EAAE;AAAA,QACnD,CAAC;AAAA,MACH;AACA,UAAI;AAAS,gBAAQ,WAAW,UAAU,SAAS,UAAU;AAAA,IAC/D;AAEA,WAAO,SAAS;AAAA,EAClB;AACF;",
  "names": []
}
